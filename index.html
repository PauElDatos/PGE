<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Presupuestos — % del gasto por política (España)</title>

  <style>
    :root{
      --uiScale: 1.35;

      --bg:#252525;
      --primary:#FEF702;
      --text:#B0B0B0;
      --grid:#4A4A4A;
      --panel:#2b2b2b;
      --stroke:#3a3a3a;

      --fontTitle: "Futura","Trebuchet MS",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      --fontText:  Arial,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;

      --radius:14px;
      --shadow: 0 10px 30px rgba(0,0,0,.25);
    }

    *{box-sizing:border-box}
    html, body{ height:100%; }

    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:var(--fontText);
      font-size: calc(14px * var(--uiScale));
    }

    header{
      padding:18px 18px 8px 18px;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
    }
    .h-title{ line-height:1.05; }
    .h-title h1{
      margin:0;
      font-family:var(--fontTitle);
      color:var(--primary);
      font-size: calc(22px * var(--uiScale));
      letter-spacing:.3px;
    }
    .h-title p{ margin:6px 0 0 0; font-size: calc(13px * var(--uiScale)); opacity:.9; }

    main{
      height: calc(100vh - 70px);
      display:grid;
      grid-template-columns: 340px 1fr;
      gap:12px;
      padding:12px 12px 18px 12px;
      min-height:0;
    }

    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
      min-height:0;
    }
    .ph{
      padding:12px 12px 10px 12px;
      border-bottom:1px solid var(--stroke);
      background:rgba(255,255,255,.02);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      min-height:44px;
    }
    .ttl{
      font-family:var(--fontTitle);
      color:var(--primary);
      font-size: calc(13px * var(--uiScale));
      letter-spacing:.35px;
      text-transform:uppercase;
      white-space:nowrap;
      flex:0 0 auto;
    }
    .sub{
      font-size: calc(12px * var(--uiScale));
      opacity:.9;
      text-align:right;
      max-width:56ch;
      white-space:nowrap;
      flex:0 0 auto;
    }

    .pc{ padding:12px; min-height:0; height:100%; }

    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.14);
      color:var(--text);
      border-radius:12px;
      padding:9px 10px;
      font-size: calc(12px * var(--uiScale));
      cursor:pointer;
      transition:.12s transform ease, .12s border-color ease, .12s color ease, .12s background ease;
      white-space:nowrap;
      user-select:none;
      line-height:1;
    }
    .btn:hover{ border-color: rgba(254,247,2,.35); color:#fff; transform: translateY(-1px); }
    .btn.active{
      border-color: rgba(254,247,2,.55);
      color: #111;
      background: rgba(254,247,2,.92);
    }
    .btn:disabled{ opacity:.5; cursor:not-allowed; transform:none; }

    .legend{
      display:flex;
      flex-direction:column;
      gap:8px;
      overflow:auto;
      height:100%;
      padding-right:4px;
    }
    .item{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      background: rgba(0,0,0,.10);
      cursor:pointer;
      user-select:none;
    }
    .item:hover{ border-color: rgba(254,247,2,.25); }
    .sw{ width:12px; height:12px; border-radius:3px; flex:0 0 auto; }
    .nm{
      flex:1 1 auto;
      font-size: calc(12px * var(--uiScale));
      line-height:1.15;
    }
    .badge{
      font-size: calc(10px * var(--uiScale));
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      opacity:.85;
      flex:0 0 auto;
    }
    .muted{ opacity:.35; }

    .chartWrap{
      height:100%;
      display:flex;
      flex-direction:column;
      min-height:0;
    }

    .svgWrap{
      position:relative;
      flex: 1 1 auto;
      min-height: 280px;
      border-radius: 12px;
      overflow: hidden;
      background: rgba(0,0,0,.08);
      border: 1px solid rgba(255,255,255,.06);
    }

    #chartSvg{
      width:100%;
      height:100%;
      display:block;
    }

    .tooltip{
      position:absolute;
      z-index:3;
      min-width: 220px;
      max-width: 360px;
      max-height: 320px;
      overflow:auto;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.82);
      backdrop-filter: blur(6px);
      border-radius: 12px;
      padding: 10px 10px;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      pointer-events:none;
      font-size: calc(12px * var(--uiScale));
      line-height: 1.25;
    }
    .ttYear{
      font-family: var(--fontTitle);
      color: var(--primary);
      letter-spacing:.2px;
      margin-bottom:6px;
      font-size: calc(13px * var(--uiScale));
    }
    .ttRow{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 3px 0;
      border-bottom: 1px dashed rgba(255,255,255,.08);
    }
    .ttRow:last-child{ border-bottom:none; }
    .ttSw{
      width:10px; height:10px; border-radius:3px; flex:0 0 auto;
    }
    .ttName{
      flex: 1 1 auto;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: rgba(255,255,255,.90);
    }
    .ttVal{
      flex:0 0 auto;
      color: rgba(255,255,255,.95);
      font-variant-numeric: tabular-nums;
    }

    .chartControls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      padding: 10px 0 0 0;
    }

    .footerSingle{
      padding:10px 0 0 0;
      font-size: calc(12px * var(--uiScale));
      opacity:.85;
    }

    .errorBox{
      position:absolute;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:18px;
      color: rgba(255,255,255,.9);
      font-size: calc(13px * var(--uiScale));
      background: rgba(0,0,0,.35);
      z-index:2;
    }

    @media (max-width: 900px){
      main{
        height:auto;
        grid-template-columns: 1fr;
      }
      .svgWrap{ height: 520px; }
      header{ align-items:flex-start; flex-direction:column; }
    }
  </style>
</head>

<body>
  <header>
    <div class="h-title">
      <h1>Presupuestos generales del Estado — España</h1>
      <p>% del Presupuesto de Gasto por Política y Año</p>
    </div>
  </header>

  <main>
    <!-- IZQUIERDA: POLÍTICAS -->
    <section class="panel">
      <div class="ph">
        <div class="ttl">Políticas</div>
        <div class="sub">
          <button class="btn" id="btnPre2004" title="Mostrar/ocultar partidas X999 (anteriores a 2004)">Anteriores a 2004</button>
        </div>
      </div>
      <div class="pc" style="padding:12px; height:100%; min-height:0;">
        <div class="legend" id="legend"></div>
      </div>
    </section>

    <!-- DERECHA: GRÁFICO -->
    <section class="panel">
      <div class="ph">
        <div class="ttl">Gráfico</div>
        <div class="sub">(% del total anual)</div>
      </div>
      <div class="pc chartWrap">
        <div class="svgWrap" id="svgWrap">
          <svg id="chartSvg" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Gráfico de porcentaje del presupuesto por política y año"></svg>
          <div class="tooltip" id="tooltip" style="display:none;"></div>
          <div class="errorBox" id="errorBox" style="display:none;"></div>
        </div>

        <div class="chartControls">
          <button class="btn" id="btnScale">Escala: Exponencial</button>
          <button class="btn" id="btnCrosshair">Línea vertical: OFF</button>
          <button class="btn" id="btnHoverFocus">Resaltar al pasar: OFF</button>
          <button class="btn" id="btnResetFocus" title="Quitar el foco fijo (click en la línea también alterna)">Reset foco</button>
        </div>

        <div class="footerSingle">
          Fuente: <span style="color:#fff">BOE</span> · <span style="opacity:.9;">N.Geolitics</span>
        </div>
      </div>
    </section>
  </main>

<script>
/* ===========================
   Utilidades (normalización)
   =========================== */
const PALETTE = { bg:"#252525", primary:"#FEF702", text:"#B0B0B0", grid:"#4A4A4A" };

function stripAccentsLower(s){
  if (s === null || s === undefined) return "";
  return String(s)
    .normalize("NFD").replace(/[̀-ͯ]/g, "")
    .toLowerCase()
    .replace(/\s+/g, " ")
    .trim();
}
function normHeader(s){
  return stripAccentsLower(s)
    .replace(/[\s_\t\u00a0]/g,"")
    .replace(/ó/g,"o").replace(/á/g,"a").replace(/é/g,"e")
    .replace(/í/g,"i").replace(/ú/g,"u").replace(/ñ/g,"n");
}
function pickCol(cols, candidates, required=true){
  const norm = new Map(cols.map(c => [normHeader(c), c]));
  for (const cand of candidates){
    const key = normHeader(cand);
    if (norm.has(key)) return norm.get(key);
  }
  if (required) throw new Error("No se encontró ninguna de las columnas: " + candidates.join(", "));
  return null;
}
function toNumber(x){
  if (x === null || x === undefined) return NaN;
  if (typeof x === "number") return x;
  const s = String(x).trim()
    .replace(/\./g, "")
    .replace(",", ".");
  const v = Number(s);
  return Number.isFinite(v) ? v : NaN;
}
function sortKeyId(idv){
  const s = String(idv ?? "").trim();
  let m = s.match(/^0*(\d+)$/);
  if (m) return [0, Number(m[1]), s];
  m = s.match(/^[xX](\d+)$/);
  if (m) return [1, Number(m[1]), s];
  return [2, 0, s];
}
function hsvToHex(h,s,v){
  let r=0,g=0,b=0;
  const i = Math.floor(h*6);
  const f = h*6 - i;
  const p = v*(1-s);
  const q = v*(1-f*s);
  const t = v*(1-(1-f)*s);
  switch(i%6){
    case 0: r=v; g=t; b=p; break;
    case 1: r=q; g=v; b=p; break;
    case 2: r=p; g=v; b=t; break;
    case 3: r=p; g=q; b=v; break;
    case 4: r=t; g=p; b=v; break;
    case 5: r=v; g=p; b=q; break;
  }
  const toHex = (x)=> {
    const n = Math.max(0, Math.min(255, Math.round(x*255)));
    return n.toString(16).padStart(2,"0");
  };
  return "#" + toHex(r)+toHex(g)+toHex(b);
}
function colorList(n, sat=0.9, val=1.0){
  if (n<=0) return [];
  const cols=[];
  for (let i=0;i<n;i++){
    cols.push(hsvToHex(i/n, sat, val));
  }
  return cols;
}

function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

function binarySearchNearest(sortedArr, target){
  let lo=0, hi=sortedArr.length-1;
  if (target <= sortedArr[0]) return 0;
  if (target >= sortedArr[hi]) return hi;
  while (hi - lo > 1){
    const mid = (lo + hi) >> 1;
    if (sortedArr[mid] === target) return mid;
    if (sortedArr[mid] < target) lo = mid; else hi = mid;
  }
  return (Math.abs(sortedArr[lo] - target) <= Math.abs(sortedArr[hi] - target)) ? lo : hi;
}

function niceStepX(span){
  if (span <= 10) return 1;
  if (span <= 20) return 2;
  if (span <= 40) return 5;
  return 10;
}
function niceStepY(ymax){
  if (ymax <= 20) return 2;
  if (ymax <= 50) return 5;
  return 10;
}

/* ===========================
   CSV parsing
   =========================== */
function splitCSVLine(line, sep){
  const out = [];
  let cur = "";
  let inQ = false;
  for (let i=0;i<line.length;i++){
    const ch = line[i];
    if (ch === '"'){
      if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
      else inQ = !inQ;
    } else if (!inQ && ch === sep){
      out.push(cur);
      cur = "";
    } else {
      cur += ch;
    }
  }
  out.push(cur);
  return out;
}
function detectSep(firstLine){
  const seps = [",",";","\t","|"];
  let best = ",";
  let bestCount = 1;
  for (const s of seps){
    const parts = splitCSVLine(firstLine, s);
    if (parts.length > bestCount){
      bestCount = parts.length;
      best = s;
    }
  }
  return best;
}
function parseCSV(text){
  text = text.replace(/^\uFEFF/, "");
  const lines = text.split(/\r?\n/).filter(l => l.trim().length>0);
  if (!lines.length) return { cols:[], rows:[] };
  const sep = detectSep(lines[0]);
  const rawCols = splitCSVLine(lines[0], sep).map(c => c.replace(/\u00a0/g," ").trim());
  const cols = rawCols;
  const rows = [];
  for (let i=1;i<lines.length;i++){
    const parts = splitCSVLine(lines[i], sep);
    const obj = {};
    for (let j=0;j<cols.length;j++){
      obj[cols[j]] = (parts[j] ?? "").replace(/\u00a0/g," ").trim();
    }
    rows.push(obj);
  }
  return { cols, rows };
}
async function fetchText(url){
  const res = await fetch(url, { cache:"no-store" });
  if (!res.ok) throw new Error("HTTP " + res.status + " al cargar " + url);
  return await res.text();
}

/* ===========================
   Lógica del script (preparar_series_pct)
   =========================== */
const PENSIONS_LABEL = "Pensiones";
const PENSIONS_PATTERNS = new Set(["pensiones"]);
const OTROS_LABEL = "otros";

const OLD31_EQUIV_LABEL = "Seguridad Social";
const OLD31_CUTOFF_YEAR = 2005;
const OLD31_POST2005_IDS = new Set(["21","22","23","25","29"]);
const OLD31_POST2005_NAME_PATTERNS = new Set([
  "pensiones",
  "otras prestaciones economicas",
  "servicios sociales y promocion social",
  "desempleo",
]);
const OLD31_PRE2005_NAMES = new Set([
  "seguridad social y proteccion social",
  "seguridad y proteccion social",
]);

function isGestionSS(nameNorm){
  return nameNorm.includes("gestion") && nameNorm.includes("seguridad social");
}

function prepararSeriesPct(dfPol, dfMeta1 /* dfMeta2 reservado */){
  const colsPol = dfPol.cols;
  const rowsPol = dfPol.rows;

  const c_id   = pickCol(colsPol, ["id_politica", "id politica"]);
  const c_year = pickCol(colsPol, ["año","ano","anio","year"]);
  const c_pol  = pickCol(colsPol, ["politica","política"]);
  const c_val  = pickCol(colsPol, ["presupuesto","presupuesto gasto","valor","importe"]);

  const base = [];
  for (const r of rowsPol){
    const id = String(r[c_id] ?? "").trim();
    const year = toNumber(r[c_year]);
    const pol = String(r[c_pol] ?? "").trim();
    const val = toNumber(r[c_val]);
    if (!id || !Number.isFinite(year) || !pol || !Number.isFinite(val)) continue;
    base.push({
      id,
      year: Math.trunc(year),
      pol,
      val,
      pol_norm: stripAccentsLower(pol),
      id_norm: String(id).trim(),
    });
  }
  if (!base.length) return null;

  const colsM1 = dfMeta1.cols;
  const rowsM1 = dfMeta1.rows;
  const c_m1_id  = pickCol(colsM1, ["id_politica"]);
  const c_m1_pol = pickCol(colsM1, ["politica","política"]);

  const meta1_sorted = rowsM1
    .map(r => ({ id: String(r[c_m1_id] ?? "").trim(), pol: String(r[c_m1_pol] ?? "").trim() }))
    .filter(r => r.id && r.pol)
    .sort((a,b)=>{
      const ka = sortKeyId(a.id);
      const kb = sortKeyId(b.id);
      return ka[0]-kb[0] || ka[1]-kb[1] || ka[2].localeCompare(kb[2]);
    });

  const id_to_name = new Map();
  for (const row of meta1_sorted){
    const idp = row.id;
    const nm = row.pol;
    if (!idp || idp === "X999") continue;
    const nm_norm = stripAccentsLower(nm);
    const label = (PENSIONS_PATTERNS.has(nm_norm) || idp === "05") ? PENSIONS_LABEL : nm;
    if (!id_to_name.has(idp)) id_to_name.set(idp, label);
  }

  function clasificar(idp, pol_name){
    idp = String(idp ?? "").trim();
    pol_name = String(pol_name ?? "").trim();
    const pol_norm = stripAccentsLower(pol_name);

    if (PENSIONS_PATTERNS.has(pol_norm) || idp === "05") return [PENSIONS_LABEL, "main"];
    if (id_to_name.has(idp)) return [id_to_name.get(idp), "main"];
    if (idp === "X999"){
      const label = pol_name ? pol_name : OTROS_LABEL;
      return [label, "x999"];
    }
    return [OTROS_LABEL, "otros"];
  }

  const gMap = new Map();
  const labelTipo = new Map();
  for (const r of base){
    const [lab, tp] = clasificar(r.id, r.pol);
    const key = lab + "||" + r.year;
    gMap.set(key, (gMap.get(key) || 0) + r.val);
    if (!labelTipo.has(lab)) labelTipo.set(lab, tp);
  }

  let g = [];
  for (const [key, sum] of gMap.entries()){
    const [lab, y] = key.split("||");
    const year = Number(y);
    const lab_norm = stripAccentsLower(lab);
    g.push({
      Label: lab,
      Año: year,
      Valor: sum,
      Label_norm: lab_norm,
      __is_gestion_ss: isGestionSS(lab_norm),
    });
  }

  g = g.filter(row => {
    if (row.Año < OLD31_CUTOFF_YEAR) return true;
    const ln = row.Label_norm;
    const isComp = (ln === "pensiones") || OLD31_POST2005_NAME_PATTERNS.has(ln) || row.__is_gestion_ss;
    return !isComp;
  });

  g = g.filter(row => {
    if (row.Año >= OLD31_CUTOFF_YEAR) return true;
    return !OLD31_PRE2005_NAMES.has(row.Label_norm);
  });

  const preMap = new Map();
  for (const r of base){
    if (r.year < OLD31_CUTOFF_YEAR && OLD31_PRE2005_NAMES.has(r.pol_norm)){
      preMap.set(r.year, (preMap.get(r.year)||0) + r.val);
    }
  }
  const postMap = new Map();
  for (const r of base){
    if (r.year >= OLD31_CUTOFF_YEAR){
      const isPost = OLD31_POST2005_IDS.has(r.id_norm) ||
                     OLD31_POST2005_NAME_PATTERNS.has(r.pol_norm) ||
                     isGestionSS(r.pol_norm);
      if (isPost){
        postMap.set(r.year, (postMap.get(r.year)||0) + r.val);
      }
    }
  }

  const comp = [];
  for (const [year,val] of preMap.entries()) comp.push({ Label: OLD31_EQUIV_LABEL, Año: year, Valor: val });
  for (const [year,val] of postMap.entries()) comp.push({ Label: OLD31_EQUIV_LABEL, Año: year, Valor: val });
  comp.sort((a,b)=>a.Año-b.Año);

  const g2 = g.map(r => ({ Label:r.Label, Año:r.Año, Valor:r.Valor })).concat(comp);

  const totMap = new Map();
  for (const r of base){
    totMap.set(r.year, (totMap.get(r.year)||0) + r.val);
  }

  const pctRows = [];
  for (const r of g2){
    const total = totMap.get(r.Año) || NaN;
    if (!Number.isFinite(total) || total === 0) continue;
    pctRows.push({
      Label: r.Label,
      Año: r.Año,
      Porcentaje: (r.Valor/total)*100,
    });
  }

  const legend_labels = [];
  for (const row of meta1_sorted){
    const idp = row.id;
    const nm = row.pol;
    if (!idp || idp === "X999") continue;
    const nm_norm = stripAccentsLower(nm);
    const lab = (PENSIONS_PATTERNS.has(nm_norm) || idp === "05") ? PENSIONS_LABEL : nm;
    if (!legend_labels.includes(lab)) legend_labels.push(lab);
  }
  if (!legend_labels.includes(OLD31_EQUIV_LABEL)) legend_labels.push(OLD31_EQUIV_LABEL);
  if (!legend_labels.includes(OTROS_LABEL)) legend_labels.push(OTROS_LABEL);

  const labelsExist = new Set(pctRows.map(r => r.Label));
  const labels_main = legend_labels.filter(lab => labelsExist.has(lab) || lab === OTROS_LABEL);

  const x999_labels = Array.from(labelTipo.entries())
    .filter(([lab,tp]) => tp === "x999")
    .map(([lab,_]) => lab)
    .sort((a,b)=>a.localeCompare(b, "es"));

  const byLabel = new Map();
  for (const r of pctRows){
    if (!byLabel.has(r.Label)) byLabel.set(r.Label, []);
    byLabel.get(r.Label).push([r.Año, r.Porcentaje]);
  }
  const series = new Map();
  let allYears = new Set();
  let yMax = 1.0;

  for (const [lab, pts] of byLabel.entries()){
    pts.sort((a,b)=>a[0]-b[0]);
    if (pts.length < 2) continue;
    const xs = pts.map(p=>p[0]);
    const ys = pts.map(p=>p[1]);
    xs.forEach(y=>allYears.add(y));
    ys.forEach(v=>{ if (Number.isFinite(v)) yMax = Math.max(yMax, v); });
    series.set(lab, { xs, ys });
  }

  const years = Array.from(allYears).sort((a,b)=>a-b);
  return { series, labels_main, x999_labels, years, y_max_pct: yMax };
}

/* ===========================
   Estado + DOM
   =========================== */
const els = {
  svgWrap: document.getElementById("svgWrap"),
  svg: document.getElementById("chartSvg"),
  tooltip: document.getElementById("tooltip"),
  legend: document.getElementById("legend"),
  btnPre2004: document.getElementById("btnPre2004"),
  btnScale: document.getElementById("btnScale"),
  btnCrosshair: document.getElementById("btnCrosshair"),
  btnHoverFocus: document.getElementById("btnHoverFocus"),
  btnResetFocus: document.getElementById("btnResetFocus"),
  errorBox: document.getElementById("errorBox"),
};

let app = {
  prepared: null,
  years: [],
  yearToIndex: new Map(),
  allLabels: [],
  labelsMain: [],
  x999Labels: [],
  showPre2004: false,

  colorMap: new Map(),
  valuesByLabel: new Map(),
  visible: new Map(),

  scaleMode: "exp",
  crosshairMode: false,
  hoverFocus: false,
  pinnedFocus: null,
  hoverLabel: null,
};

function setButtonState(btn, isOn){
  btn.classList.toggle("active", !!isOn);
}

function buildColorMap(prep){
  const { labels_main, x999_labels, series } = prep;

  const mainCols = colorList(labels_main.length, 0.9, 1.0);
  const cm = new Map();
  labels_main.forEach((lab,i)=> cm.set(lab, mainCols[i] || PALETTE.text));

  cm.set(OTROS_LABEL, "rgba(176,176,176,.85)");

  const xCols = colorList(x999_labels.length, 0.35, 0.95);
  x999_labels.forEach((lab,i)=> cm.set(lab, xCols[i] || "rgba(176,176,176,.55)"));

  for (const lab of series.keys()){
    if (!cm.has(lab)) cm.set(lab, "rgba(176,176,176,.7)");
  }
  return cm;
}

function buildAlignedValues(prep){
  const years = prep.years;
  const n = years.length;
  const yearToIndex = new Map(years.map((y,i)=>[y,i]));
  const valuesByLabel = new Map();

  for (const [lab, s] of prep.series.entries()){
    const arr = new Float64Array(n);
    for (let i=0;i<n;i++) arr[i] = NaN;
    for (let i=0;i<s.xs.length;i++){
      const y = s.xs[i];
      const idx = yearToIndex.get(y);
      if (idx !== undefined) arr[idx] = s.ys[i];
    }
    valuesByLabel.set(lab, arr);
  }
  return { years, yearToIndex, valuesByLabel };
}

function effectiveFocusLabel(){
  if (app.pinnedFocus) return app.pinnedFocus;
  if (app.hoverFocus) return app.hoverLabel;
  return null;
}

/* ===========================
   Leyenda (Políticas)
   =========================== */
function buildLegend(){
  els.legend.innerHTML = "";

  const labelsToShow = [...app.labelsMain];
  if (app.showPre2004){
    labelsToShow.push(...app.x999Labels);
  }

  for (const lab of labelsToShow){
    if (!app.valuesByLabel.has(lab)) continue;
    const color = app.colorMap.get(lab) || PALETTE.text;

    const el = document.createElement("div");
    el.className = "item";
    el.dataset.label = lab;

    const badgeTxt = app.x999Labels.includes(lab) ? "pre-2004" : "main";
    el.innerHTML = `
      <span class="sw" style="background:${color}"></span>
      <span class="nm">${lab}</span>
      <span class="badge">${badgeTxt}</span>
    `;

    const isVis = app.visible.get(lab) !== false;
    el.classList.toggle("muted", !isVis);

    el.addEventListener("click", ()=>{
      const now = !(app.visible.get(lab) !== false);
      app.visible.set(lab, now);
      el.classList.toggle("muted", !now);
      draw();
    });

    el.addEventListener("dblclick", (e)=>{
      e.preventDefault();
      togglePinnedFocus(lab);
    });

    els.legend.appendChild(el);
  }

  syncLegendFocusMuted();
}

function syncLegendFocusMuted(){
  const focus = effectiveFocusLabel();
  const items = els.legend.querySelectorAll(".item");
  items.forEach(it=>{
    const lab = it.dataset.label;
    if (!focus){
      const isVis = app.visible.get(lab) !== false;
      it.classList.toggle("muted", !isVis);
    } else {
      const isVis = app.visible.get(lab) !== false;
      const keep = (lab === focus);
      it.classList.toggle("muted", !isVis || !keep);
    }
  });
}

/* ===========================
   SVG rendering
   =========================== */
function createSvgEl(tag, attrs={}){
  const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
  for (const [k,v] of Object.entries(attrs)){
    el.setAttribute(k, String(v));
  }
  return el;
}

function formatPct(v){
  if (!Number.isFinite(v)) return "—";
  return v.toFixed(2) + "%";
}

function yTransform(v){
  if (app.scaleMode === "log"){
    return Math.log10(1 + Math.max(0, v));
  }
  return v;
}

function computeYMaxVisible(){
  let ymax = 1;
  for (const lab of app.allLabels){
    if (app.visible.get(lab) === false) continue;
    const arr = app.valuesByLabel.get(lab);
    if (!arr) continue;
    for (let i=0;i<arr.length;i++){
      const v = arr[i];
      if (Number.isFinite(v)) ymax = Math.max(ymax, v);
    }
  }
  return ymax;
}

function computeYTicks(ymax){
  if (app.scaleMode === "log"){
    const candidates = [0,1,2,5,10,15,20,30,40,50,60,80,100];
    const t = candidates.filter(v => v <= ymax + 1e-9);
    if (t.length < 4){
      return [0, Math.max(1, Math.round(ymax/3)), Math.max(2, Math.round(2*ymax/3)), Math.ceil(ymax)];
    }
    return t;
  }
  const step = niceStepY(ymax);
  const yTop = Math.max(10, Math.ceil(ymax/step)*step);
  const out = [];
  for (let v=0; v<=yTop+1e-9; v+=step) out.push(v);
  return out;
}

function computeXTicks(minYear, maxYear){
  const step = niceStepX(maxYear - minYear);
  const start = Math.ceil(minYear/step)*step;
  const out = [];
  for (let y=start; y<=maxYear+1e-9; y+=step) out.push(y);
  if (out[0] !== minYear) out.unshift(minYear);
  if (out[out.length-1] !== maxYear) out.push(maxYear);
  return Array.from(new Set(out)).sort((a,b)=>a-b);
}

function buildPathForLabel(lab, xScale, yScale){
  const s = app.prepared.series.get(lab);
  if (!s) return "";
  let d = "";
  for (let i=0;i<s.xs.length;i++){
    const x = xScale(s.xs[i]);
    const y = yScale(s.ys[i]);
    if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
    d += (d ? " L " : "M ") + x.toFixed(2) + " " + y.toFixed(2);
  }
  return d;
}

let lastGeom = null;
let rafPending = false;
let lastPointer = null;

function draw(){
  if (!app.prepared) return;

  const wrap = els.svgWrap;
  const w = Math.max(420, wrap.clientWidth);
  const h = Math.max(320, wrap.clientHeight);

  const svg = els.svg;
  svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
  svg.setAttribute("preserveAspectRatio", "none");
  svg.innerHTML = "";

  const margin = { l: 74, r: 18, t: 18, b: 56 };
  const plotW = Math.max(10, w - margin.l - margin.r);
  const plotH = Math.max(10, h - margin.t - margin.b);

  const years = app.years;
  const minYear = years[0], maxYear = years[years.length-1];

  const xScale = (year)=> margin.l + ((year - minYear) / (maxYear - minYear)) * plotW;
  const xInv = (px)=> minYear + ((px - margin.l) / plotW) * (maxYear - minYear);

  const yMaxOrig = computeYMaxVisible();
  const yTicks = computeYTicks(yMaxOrig);

  const yMaxT = Math.max(0.0001, Math.max(...yTicks.map(v => yTransform(v))));
  const yScale = (v)=> margin.t + plotH - (yTransform(v) / yMaxT) * plotH;

  lastGeom = { w,h, margin, plotW, plotH, minYear, maxYear, xScale, xInv, yScale, yTicks, yMaxOrig, yMaxT };

  svg.appendChild(createSvgEl("rect", { x:0, y:0, width:w, height:h, fill:"rgba(0,0,0,0)" }));

  const gGrid = createSvgEl("g", {});
  const gAxes = createSvgEl("g", {});
  const gLines = createSvgEl("g", {});
  const gOverlay = createSvgEl("g", {});

  const xTicks = computeXTicks(minYear, maxYear);

  for (const yy of xTicks){
    const x = xScale(yy);
    gGrid.appendChild(createSvgEl("line", {
      x1:x, y1:margin.t, x2:x, y2:margin.t+plotH,
      stroke:"rgba(74,74,74,.38)", "stroke-width":1
    }));
    const t = createSvgEl("text", {
      x:x, y: margin.t+plotH+18,
      fill:"rgba(176,176,176,.95)",
      "text-anchor":"middle",
      "font-size": 12,
      "font-family":"Arial, system-ui, sans-serif",
    });
    t.textContent = yy;
    gAxes.appendChild(t);
  }

  for (const tval of yTicks){
    const y = yScale(tval);
    gGrid.appendChild(createSvgEl("line", {
      x1:margin.l, y1:y, x2:margin.l+plotW, y2:y,
      stroke:"rgba(74,74,74,.38)", "stroke-width":1
    }));
    const tx = createSvgEl("text", {
      x: margin.l-10, y: y+4,
      fill:"rgba(176,176,176,.95)",
      "text-anchor":"end",
      "font-size": 12,
      "font-family":"Arial, system-ui, sans-serif",
    });
    tx.textContent = tval;
    gAxes.appendChild(tx);
  }

  gAxes.appendChild(createSvgEl("line", {
    x1: margin.l, y1: margin.t+plotH, x2: margin.l+plotW, y2: margin.t+plotH,
    stroke:"rgba(176,176,176,.7)", "stroke-width":1.25
  }));
  gAxes.appendChild(createSvgEl("line", {
    x1: margin.l, y1: margin.t, x2: margin.l, y2: margin.t+plotH,
    stroke:"rgba(176,176,176,.7)", "stroke-width":1.25
  }));

  const xTitle = createSvgEl("text", {
    x: margin.l + plotW/2, y: margin.t+plotH+42,
    fill:"rgba(176,176,176,.95)",
    "text-anchor":"middle",
    "font-size": 13,
    "font-family":"Arial, system-ui, sans-serif",
  });
  xTitle.textContent = "Año";
  gAxes.appendChild(xTitle);

  const yTitle = createSvgEl("text", {
    x: 18, y: margin.t + plotH/2,
    fill:"rgba(176,176,176,.95)",
    "text-anchor":"middle",
    "font-size": 13,
    "font-family":"Arial, system-ui, sans-serif",
    transform: `rotate(-90 18 ${margin.t + plotH/2})`
  });
  yTitle.textContent = "Porcentaje del total (%)";
  gAxes.appendChild(yTitle);

  const focus = effectiveFocusLabel();
  for (const lab of app.allLabels){
    const d = buildPathForLabel(lab, xScale, yScale);
    if (!d) continue;

    const isVis = app.visible.get(lab) !== false;
    const isFocus = !!focus && (lab === focus);

    const opacity = !isVis ? 0 : (!focus ? 1.0 : (isFocus ? 1.0 : 0.12));
    const strokeW = !focus ? 2.0 : (isFocus ? 3.0 : 1.5);

    const path = createSvgEl("path", {
      d,
      fill:"none",
      stroke: app.colorMap.get(lab) || "rgba(176,176,176,.7)",
      "stroke-width": strokeW,
      "stroke-linejoin":"round",
      "stroke-linecap":"round",
      "vector-effect":"non-scaling-stroke",
      opacity: opacity,
      "data-label": lab,
      style: "pointer-events:none;"
    });
    gLines.appendChild(path);
  }

  const crosshair = createSvgEl("line", {
    x1: margin.l, y1: margin.t, x2: margin.l, y2: margin.t+plotH,
    stroke: "rgba(254,247,2,.55)",
    "stroke-width": 1.5,
    opacity: 0,
    "vector-effect":"non-scaling-stroke",
    id: "crosshairLine",
  });
  const dot = createSvgEl("circle", {
    cx: margin.l, cy: margin.t,
    r: 4.5,
    fill: "rgba(254,247,2,.95)",
    stroke: "rgba(0,0,0,.55)",
    "stroke-width": 1,
    opacity: 0,
    id: "hoverDot",
  });

  const hit = createSvgEl("rect", {
    x: margin.l, y: margin.t,
    width: plotW, height: plotH,
    fill: "rgba(0,0,0,0)",
    id: "hitRect",
    style: "cursor:crosshair;"
  });

  gOverlay.appendChild(crosshair);
  gOverlay.appendChild(dot);
  gOverlay.appendChild(hit);

  svg.appendChild(gGrid);
  svg.appendChild(gAxes);
  svg.appendChild(gLines);
  svg.appendChild(gOverlay);

  syncLegendFocusMuted();

  if (lastPointer){
    handlePointer(lastPointer, true);
  }

  attachPointerHandlers();
}

function svgPointFromEvent(ev){
  const rect = els.svg.getBoundingClientRect();
  const vb = els.svg.viewBox.baseVal;
  const sx = vb.width / rect.width;
  const sy = vb.height / rect.height;
  const x = (ev.clientX - rect.left) * sx;
  const y = (ev.clientY - rect.top) * sy;
  return { x, y };
}

function nearestVisibleLabelAtYearIdx(yearIdx, xPix, yPix){
  let best = null;
  let bestDist = Infinity;

  for (const lab of app.allLabels){
    if (app.visible.get(lab) === false) continue;

    const arr = app.valuesByLabel.get(lab);
    if (!arr) continue;
    const v = arr[yearIdx];
    if (!Number.isFinite(v)) continue;

    const yy = lastGeom.yScale(v);

    const dx = Math.abs(xPix - lastGeom.xScale(app.years[yearIdx]));
    const dy = Math.abs(yPix - yy);
    const d = Math.hypot(dx, dy);
    if (d < bestDist){
      bestDist = d;
      best = { lab, v, yy, d };
    }
  }
  return best;
}

function buildTooltipAll(yearIdx){
  const year = app.years[yearIdx];
  const rows = [];

  for (const lab of app.allLabels){
    if (app.visible.get(lab) === false) continue;
    const arr = app.valuesByLabel.get(lab);
    if (!arr) continue;
    const v = arr[yearIdx];
    rows.push({ lab, v, color: app.colorMap.get(lab) || PALETTE.text });
  }

  rows.sort((a,b)=>{
    const av = Number.isFinite(a.v) ? a.v : -1;
    const bv = Number.isFinite(b.v) ? b.v : -1;
    return bv - av;
  });

  let html = `<div class="ttYear">Año ${year}</div>`;
  for (const r of rows){
    html += `
      <div class="ttRow">
        <span class="ttSw" style="background:${r.color}"></span>
        <span class="ttName">${r.lab}</span>
        <span class="ttVal">${formatPct(r.v)}</span>
      </div>
    `;
  }
  return html;
}

function buildTooltipSingle(yearIdx, lab, v){
  const year = app.years[yearIdx];
  const color = app.colorMap.get(lab) || PALETTE.text;
  return `
    <div class="ttYear">Año ${year}</div>
    <div class="ttRow">
      <span class="ttSw" style="background:${color}"></span>
      <span class="ttName">${lab}</span>
      <span class="ttVal">${formatPct(v)}</span>
    </div>
  `;
}

function placeTooltip(xPix, yPix){
  const tip = els.tooltip;
  const wrapRect = els.svgWrap.getBoundingClientRect();
  const vb = els.svg.viewBox.baseVal;

  const xCss = (xPix / vb.width) * wrapRect.width;
  const yCss = (yPix / vb.height) * wrapRect.height;

  const pad = 12;
  const offset = 14;

  tip.style.display = "block";

  const tw = tip.offsetWidth || 260;
  const th = tip.offsetHeight || 180;

  let left = xCss + offset;
  let top  = yCss + offset;

  if (left + tw + pad > wrapRect.width) left = xCss - tw - offset;
  if (left < pad) left = pad;

  if (top + th + pad > wrapRect.height) top = yCss - th - offset;
  if (top < pad) top = pad;

  tip.style.left = left + "px";
  tip.style.top  = top + "px";
}

function hideTooltipAndGuides(){
  els.tooltip.style.display = "none";
  const ch = els.svg.querySelector("#crosshairLine");
  const dot = els.svg.querySelector("#hoverDot");
  if (ch) ch.setAttribute("opacity", "0");
  if (dot) dot.setAttribute("opacity", "0");
  app.hoverLabel = null;
  if (app.hoverFocus && !app.pinnedFocus){
    draw();
  }
}

function handlePointer(ev, fromRedraw=false){
  if (!lastGeom) return;
  lastPointer = ev;

  const p = svgPointFromEvent(ev);
  const { margin, plotW, plotH } = lastGeom;

  const inside = (p.x >= margin.l && p.x <= margin.l + plotW && p.y >= margin.t && p.y <= margin.t + plotH);
  if (!inside){
    hideTooltipAndGuides();
    return;
  }

  const yearApprox = lastGeom.xInv(p.x);
  const yearIdx = binarySearchNearest(app.years, yearApprox);
  const year = app.years[yearIdx];
  const xPix = lastGeom.xScale(year);

  const ch = els.svg.querySelector("#crosshairLine");
  const dot = els.svg.querySelector("#hoverDot");

  if (app.crosshairMode){
    if (ch){
      ch.setAttribute("x1", xPix);
      ch.setAttribute("x2", xPix);
      ch.setAttribute("opacity", "1");
    }
    els.tooltip.innerHTML = buildTooltipAll(yearIdx);
    placeTooltip(p.x, p.y);

    const pick = nearestVisibleLabelAtYearIdx(yearIdx, xPix, p.y);
    if (pick && pick.d <= 16){
      app.hoverLabel = pick.lab;
      if (dot){
        dot.setAttribute("cx", xPix);
        dot.setAttribute("cy", pick.yy);
        dot.setAttribute("opacity", "1");
      }
      if (app.hoverFocus && !app.pinnedFocus && !fromRedraw){
        draw();
      }
    } else {
      app.hoverLabel = null;
      if (dot) dot.setAttribute("opacity", "0");
      if (app.hoverFocus && !app.pinnedFocus && !fromRedraw){
        draw();
      }
    }
    return;
  }

  const pick = nearestVisibleLabelAtYearIdx(yearIdx, xPix, p.y);
  if (!pick || pick.d > 14){
    hideTooltipAndGuides();
    return;
  }

  app.hoverLabel = pick.lab;
  if (app.hoverFocus && !app.pinnedFocus && !fromRedraw){
    draw();
  }

  if (dot){
    dot.setAttribute("cx", xPix);
    dot.setAttribute("cy", pick.yy);
    dot.setAttribute("opacity", "1");
  }
  if (ch) ch.setAttribute("opacity", "0");

  els.tooltip.innerHTML = buildTooltipSingle(yearIdx, pick.lab, pick.v);
  placeTooltip(xPix, pick.yy);
}

function togglePinnedFocus(lab){
  if (app.pinnedFocus === lab){
    app.pinnedFocus = null;
  } else {
    app.pinnedFocus = lab;
  }
  draw();
}

/* ===========================
   Eventos UI
   =========================== */
els.btnPre2004.addEventListener("click", ()=>{
  app.showPre2004 = !app.showPre2004;
  setButtonState(els.btnPre2004, app.showPre2004);

  for (const lab of app.x999Labels){
    app.visible.set(lab, app.showPre2004);
  }

  if (!app.showPre2004 && app.pinnedFocus && app.x999Labels.includes(app.pinnedFocus)){
    app.pinnedFocus = null;
  }

  buildLegend();
  draw();
});

els.btnScale.addEventListener("click", ()=>{
  app.scaleMode = (app.scaleMode === "exp") ? "log" : "exp";
  els.btnScale.textContent = (app.scaleMode === "exp") ? "Escala: Exponencial" : "Escala: Logarítmica";
  setButtonState(els.btnScale, app.scaleMode === "log");
  draw();
});

els.btnCrosshair.addEventListener("click", ()=>{
  app.crosshairMode = !app.crosshairMode;
  els.btnCrosshair.textContent = app.crosshairMode ? "Línea vertical: ON" : "Línea vertical: OFF";
  setButtonState(els.btnCrosshair, app.crosshairMode);
  hideTooltipAndGuides();
});

els.btnHoverFocus.addEventListener("click", ()=>{
  app.hoverFocus = !app.hoverFocus;
  els.btnHoverFocus.textContent = app.hoverFocus ? "Resaltar al pasar: ON" : "Resaltar al pasar: OFF";
  setButtonState(els.btnHoverFocus, app.hoverFocus);
  app.hoverLabel = null;
  draw();
});

els.btnResetFocus.addEventListener("click", ()=>{
  app.pinnedFocus = null;
  app.hoverLabel = null;
  hideTooltipAndGuides();
  draw();
});

/* pointer handlers */
function attachPointerHandlers(){
  const hit = els.svg.querySelector("#hitRect");
  if (!hit) return;

  hit.onmousemove = (ev)=>{
    if (rafPending){
      lastPointer = ev;
      return;
    }
    rafPending = true;
    lastPointer = ev;
    requestAnimationFrame(()=>{
      rafPending = false;
      handlePointer(lastPointer);
    });
  };

  hit.onmouseleave = ()=>{
    hideTooltipAndGuides();
  };

  hit.onclick = (ev)=>{
    if (!lastGeom) return;
    const p = svgPointFromEvent(ev);
    const { margin, plotW, plotH } = lastGeom;

    const inside = (p.x >= margin.l && p.x <= margin.l + plotW && p.y >= margin.t && p.y <= margin.t + plotH);
    if (!inside) return;

    const yearApprox = lastGeom.xInv(p.x);
    const yearIdx = binarySearchNearest(app.years, yearApprox);
    const year = app.years[yearIdx];
    const xPix = lastGeom.xScale(year);

    const pick = nearestVisibleLabelAtYearIdx(yearIdx, xPix, p.y);
    if (!pick || pick.d > 14) return;

    togglePinnedFocus(pick.lab);
  };
}

const ro = new ResizeObserver(()=>{ draw(); });
ro.observe(els.svgWrap);

/* ===========================
   Carga de datos
   =========================== */
async function loadDataDefault(){
  const polUrl = "pge_politicas.csv";
  const meta1Url = "pge_politicas_metadata_1.csv";
  const meta2Url = "pge_politicas_metadata_2.csv";

  const [polTxt, m1Txt, m2Txt] = await Promise.all([
    fetchText(polUrl),
    fetchText(meta1Url),
    fetchText(meta2Url),
  ]);

  const dfPol = parseCSV(polTxt);
  const dfM1 = parseCSV(m1Txt);
  const dfM2 = parseCSV(m2Txt);

  const prep = prepararSeriesPct(dfPol, dfM1, dfM2);
  if (!prep) throw new Error("Los CSV se cargaron pero no hay filas válidas.");
  return prep;
}

function showError(msg){
  els.errorBox.style.display = "flex";
  els.errorBox.textContent = msg;
}

/* ===========================
   Inicio
   =========================== */
(async function init(){
  try{
    const prep = await loadDataDefault();
    app.prepared = prep;

    app.labelsMain = prep.labels_main;
    app.x999Labels = prep.x999_labels;
    app.allLabels = Array.from(prep.series.keys());

    app.colorMap = buildColorMap(prep);

    const aligned = buildAlignedValues(prep);
    app.years = aligned.years;
    app.yearToIndex = aligned.yearToIndex;
    app.valuesByLabel = aligned.valuesByLabel;

    for (const lab of app.allLabels){
      const isX = app.x999Labels.includes(lab);
      app.visible.set(lab, !isX);
    }

    setButtonState(els.btnPre2004, false);
    setButtonState(els.btnScale, false);
    setButtonState(els.btnCrosshair, false);
    setButtonState(els.btnHoverFocus, false);

    buildLegend();
    draw();
  } catch (e){
    console.error(e);
    showError("No puedo cargar los CSV necesarios (pge_politicas.csv, pge_politicas_metadata_1.csv, pge_politicas_metadata_2.csv).");
  }
})();
</script>
</body>
</html>
