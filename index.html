<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>entendiendo la economía de España</title>

  <style>
    :root{
      --uiScale: 1.35;

      --bg:#252525;
      --primary:#FEF702;
      --text:#B0B0B0;
      --grid:#4A4A4A;
      --stroke:#3a3a3a;

      --fontTitle: "Futura","Trebuchet MS",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      --fontText:  Arial,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;

      --radius:14px;
      --shadow: 0 10px 30px rgba(0,0,0,.25);
    }

    *{box-sizing:border-box}
    html, body{ height:100%; }

    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:var(--fontText);
      font-size: calc(14px * var(--uiScale));

      display:flex;
      flex-direction:column;
      height:100vh;
      min-height:100vh;
      overflow:hidden;
    }

    header{
      padding:18px 18px 8px 18px;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      flex: 0 0 auto;
    }

    .h-title{ line-height:1.05; }
    .h-title h1{
      margin:0;
      font-family:var(--fontTitle);
      color:var(--primary);
      font-size: calc(22px * var(--uiScale));
      letter-spacing:.3px;
    }

    .tabs{
      margin-top:10px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    main{
      flex: 1 1 auto;
      min-height:0;
      display:grid;
      grid-template-columns: 340px 1fr;
      gap:12px;
      padding:12px 12px 18px 12px;
      overflow:hidden;
    }

    .view{ display:none !important; }
    .view.active{ display:grid !important; }

    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      min-height:0;
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    .ph{
      padding:12px 12px 10px 12px;
      border-bottom:1px solid var(--stroke);
      background:rgba(255,255,255,.02);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      min-height:44px;
      flex: 0 0 auto;
    }
    .ttl{
      font-family:var(--fontTitle);
      color:var(--primary);
      font-size: calc(13px * var(--uiScale));
      letter-spacing:.35px;
      text-transform:uppercase;
      white-space:nowrap;
      flex:0 0 auto;
    }
    .sub{
      font-size: calc(12px * var(--uiScale));
      opacity:.8;
      white-space:nowrap;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
      flex:1 1 auto;
    }

    .pc{
      padding:12px;
      overflow:auto;
      min-height:0;
      flex: 1 1 auto;
    }

    /* Botones */
    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color: rgba(255,255,255,.9);
      padding: 9px 12px;
      border-radius: 10px;
      font-size: calc(12px * var(--uiScale));
      cursor:pointer;
      user-select:none;
      transition: transform .04s ease, border-color .12s ease, background .12s ease;
      line-height:1;
      white-space:nowrap;
    }
    .btn:hover{ border-color: rgba(254,247,2,.35); background: rgba(255,255,255,.06); }
    .btn:active{ transform: translateY(1px); }
    .btn.on{
      background: rgba(254,247,2,.9);
      border-color: rgba(254,247,2,.95);
      color: rgba(0,0,0,.92);
      font-weight: 700;
    }
    .btn.tab{
      border-radius: 999px;
      padding: 10px 14px;
    }

    /* Leyenda/lista */
    .legend{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .item{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 10px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.02);
      border-radius:12px;
      box-shadow: 0 6px 18px rgba(0,0,0,.10);
      cursor:pointer;
      user-select:none;
      min-width:0;
    }
    .item:hover{ border-color: rgba(254,247,2,.25); }
    .sw{ width:12px; height:12px; border-radius:3px; flex:0 0 auto; }
    .nm{
      flex:1 1 auto;
      font-size: calc(12px * var(--uiScale));
      line-height:1.15;
      min-width:0;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .badge{
      font-size: calc(10px * var(--uiScale));
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      opacity:.85;
      flex:0 0 auto;
    }
    .muted{ opacity:.35; }

    /* GRÁFICO */
    .chartPc{
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:hidden;
      min-height:0;
    }

    .svgWrap{
      position:relative;
      flex: 1 1 0;
      min-height:0;
      border-radius: 12px;
      overflow: hidden;
      background: rgba(0,0,0,.08);
      border: 1px solid rgba(255,255,255,.06);
    }

    svg.chartSvg{
      width:100%;
      height:100%;
      display:block;
    }

    .tooltip{
      position:absolute;
      z-index:3;
      min-width: 240px;
      max-width: 420px;
      max-height: 420px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.82);
      backdrop-filter: blur(6px);
      border-radius: 12px;
      padding: 10px 10px;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      pointer-events:none;
      font-size: calc(12px * var(--uiScale));
      line-height: 1.25;
    }
    .ttYear{
      font-family: var(--fontTitle);
      color: var(--primary);
      letter-spacing:.2px;
      margin-bottom:6px;
      font-size: calc(13px * var(--uiScale));
    }
    .ttRow{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 3px 0;
      border-bottom: 1px dashed rgba(255,255,255,.08);
    }
    .ttRow:last-child{ border-bottom:none; }
    .ttSw{
      width:10px; height:10px; border-radius:3px; flex:0 0 auto;
    }
    .ttName{
      flex: 1 1 auto;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: rgba(255,255,255,.90);
      min-width:0;
    }
    .ttVal{
      flex:0 0 auto;
      color: rgba(255,255,255,.95);
      font-variant-numeric: tabular-nums;
      white-space:nowrap;
    }

    .chartControls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      flex: 0 0 auto;
    }

    .footerSingle{
      flex: 0 0 auto;
      font-size: calc(12px * var(--uiScale));
      opacity:.85;
      padding-bottom: 2px;
    }

    .errorBox{
      position:absolute;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:18px;
      color: rgba(255,255,255,.90);
      font-size: calc(13px * var(--uiScale));
      background: rgba(0,0,0,.35);
      z-index:2;
    }

    @media (max-width: 900px){
      body{ overflow:auto; }
      main{
        overflow:visible;
        grid-template-columns: 1fr;
      }
      .svgWrap{ height: 520px; min-height: 520px; }
      .pc{ overflow:visible; }
    }
  </style>
</head>

<body>
  <header>
    <div class="h-title">
      <h1>entendiendo la economía de España</h1>
      <div class="tabs" role="tablist" aria-label="Secciones">
        <button class="btn tab on" data-view="pge" role="tab" aria-selected="true">Presupuestos generales del Estado</button>
        <button class="btn tab" data-view="gb" role="tab" aria-selected="false">Gasto vs beneficio</button>
        <button class="btn tab" data-view="pa" role="tab" aria-selected="false">Poder adquisitivo</button>
      </div>
    </div>
  </header>

  <!-- ===================== VISTA 1: PGE ===================== -->
  <main id="viewPGE" class="view active">
    <section class="panel">
      <div class="ph">
        <div class="ttl">Políticas</div>
        <div class="sub">
          <button class="btn" id="btnPre2004" title="Mostrar/ocultar partidas anteriores a 2004">Anteriores a 2004</button>
        </div>
      </div>
      <div class="pc">
        <div class="legend" id="legend"></div>
      </div>
    </section>

    <section class="panel">
      <div class="ph">
        <div class="ttl">Gráfico</div>
        <div class="sub">(% del total anual)</div>
      </div>

      <div class="pc chartPc">
        <div class="svgWrap" id="svgWrap">
          <svg id="chartSvg" class="chartSvg" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Gráfico de porcentaje del presupuesto por política y año"></svg>
          <div class="tooltip" id="tooltip" style="display:none;"></div>
          <div class="errorBox" id="errorBox" style="display:none;"></div>
        </div>

        <div class="chartControls">
          <button class="btn" id="btnScale">Escala: Exponencial</button>
          <button class="btn" id="btnCrosshair">Línea vertical: OFF</button>
          <button class="btn" id="btnHoverFocus">Resaltar al pasar: OFF</button>
          <button class="btn" id="btnResetFocus" title="Quitar selección">Reset foco</button>
        </div>

        <div class="footerSingle">
          Fuente: <span style="color:#fff">BOE</span> · <span style="opacity:.9;">N.Geolitics</span>
        </div>
      </div>
    </section>
  </main>

  <!-- ===================== VISTA 2: Gasto vs beneficio ===================== -->
  <main id="viewGB" class="view">
    <section class="panel">
      <div class="ph">
        <div class="ttl">Series</div>
        <div class="sub">1986–2023</div>
      </div>
      <div class="pc">
        <div class="legend" id="legendGB"></div>
      </div>
    </section>

    <section class="panel">
      <div class="ph">
        <div class="ttl">Gráfico</div>
        <div class="sub">Izq: totales (B€) · Dcha: per cápita (k€)</div>
      </div>

      <div class="pc chartPc">
        <div class="svgWrap" id="svgWrapGB">
          <svg id="chartSvgGB" class="chartSvg" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Gráfico de PIB y gasto público en euros constantes 1986"></svg>
          <div class="tooltip" id="tooltipGB" style="display:none;"></div>
          <div class="errorBox" id="errorBoxGB" style="display:none;"></div>
        </div>

        <div class="chartControls">
          <button class="btn" id="btnScaleGB">Escala: Exponencial</button>
          <button class="btn" id="btnCrosshairGB">Línea vertical: OFF</button>
          <button class="btn" id="btnHoverFocusGB">Resaltar al pasar: OFF</button>
          <button class="btn" id="btnResetFocusGB" title="Quitar selección">Reset foco</button>
        </div>

        <div class="footerSingle">
          Fuente: <span style="color:#fff">BM</span> (PIB/IPC), <span style="color:#fff">INE</span> (población), <span style="color:#fff">PGE</span> (gasto). Precios de 1986. · <span style="opacity:.9;">N.Geolitics</span>
        </div>
      </div>
    </section>
  </main>

  <!-- ===================== VISTA 3: Poder adquisitivo ===================== -->
  <main id="viewPA" class="view">
    <section class="panel">
      <div class="ph">
        <div class="ttl">Serie</div>
        <div class="sub">1986–2023</div>
      </div>
      <div class="pc">
        <div class="legend" id="legendPA"></div>
      </div>
    </section>

    <section class="panel">
      <div class="ph">
        <div class="ttl">Gráfico</div>
        <div class="sub">(% del PIB per cápita)</div>
      </div>

      <div class="pc chartPc">
        <div class="svgWrap" id="svgWrapPA">
          <svg id="chartSvgPA" class="chartSvg" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Gráfico de gasto público per cápita como porcentaje del PIB per cápita"></svg>
          <div class="tooltip" id="tooltipPA" style="display:none;"></div>
          <div class="errorBox" id="errorBoxPA" style="display:none;"></div>
        </div>

        <div class="chartControls">
          <button class="btn" id="btnScalePA">Escala: Exponencial</button>
          <button class="btn" id="btnCrosshairPA">Línea vertical: OFF</button>
          <button class="btn" id="btnHoverFocusPA">Resaltar al pasar: OFF</button>
          <button class="btn" id="btnResetFocusPA" title="Quitar selección">Reset foco</button>
        </div>

        <div class="footerSingle">
          Fuente: <span style="color:#fff">Banco Mundial</span>, <span style="color:#fff">INE</span>, <span style="color:#fff">BOE</span>, <span style="color:#fff">FRED</span>. · <span style="opacity:.9;">N.Geolitics</span>
        </div>
      </div>
    </section>
  </main>

<script>
/* ===================== Tabs ===================== */
(function(){
  const btns = Array.from(document.querySelectorAll(".tabs .btn.tab"));
  const views = {
    pge: document.getElementById("viewPGE"),
    gb:  document.getElementById("viewGB"),
    pa:  document.getElementById("viewPA"),
  };

  function setView(k){
    for (const [key, el] of Object.entries(views)){
      el.classList.toggle("active", key === k);
    }
    for (const b of btns){
      const on = b.dataset.view === k;
      b.classList.toggle("on", on);
      b.setAttribute("aria-selected", on ? "true" : "false");
    }
    // Recalcular geometría de gráficos visibles
    if (k === "pge") window.__pge?.onShow?.();
    if (k === "gb")  window.__gb?.onShow?.();
    if (k === "pa")  window.__pa?.onShow?.();
  }

  btns.forEach(b => b.addEventListener("click", () => setView(b.dataset.view)));
  setView("pge");
})();

/* ===================== Helpers comunes ===================== */
function stripAccentsLower(s){
  if (s === null || s === undefined) return "";
  return String(s)
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .replace(/\s+/g, " ")
    .trim();
}
function normHeader(s){
  return stripAccentsLower(s)
    .replace(/[\s_\t\u00a0]/g,"")
    .replace(/[^\p{L}\p{N}]/gu,"");
}
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function toNum(v){
  if (v === null || v === undefined) return NaN;
  const s = String(v).replace(/\./g,"").replace(",",".").trim();
  const x = Number(s);
  return Number.isFinite(x) ? x : NaN;
}
function createSvgEl(tag, attrs={}){
  const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
  for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));
  return el;
}
async function fetchText(url){
  const r = await fetch(url, { cache: "no-store" });
  if (!r.ok) throw new Error(`No se pudo cargar ${url} (HTTP ${r.status})`);
  return await r.text();
}
function parseCSV(text){
  const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n").filter(l => l.trim().length);
  if (!lines.length) return { headers: [], rows: [] };

  const seps = [",",";","\t","|"];
  function scoreSep(sep){
    let score = 0;
    for (let i=0;i<Math.min(12, lines.length);i++){
      score += (lines[i].match(new RegExp("\\"+sep, "g"))||[]).length;
    }
    return score;
  }
  let sep = ",";
  let best = -1;
  for (const s of seps){
    const sc = scoreSep(s);
    if (sc > best){ best = sc; sep = s; }
  }

  function splitCSVLine(line){
    const out = [];
    let cur = "";
    let inQ = false;
    for (let i=0;i<line.length;i++){
      const ch = line[i];
      if (inQ){
        if (ch === '"'){
          if (line[i+1] === '"'){ cur += '"'; i++; }
          else inQ = false;
        } else cur += ch;
      } else {
        if (ch === '"') inQ = true;
        else if (ch === sep){ out.push(cur); cur=""; }
        else cur += ch;
      }
    }
    out.push(cur);
    return out;
  }

  const headers = splitCSVLine(lines[0]).map(h => h.trim());
  const rows = [];
  for (let i=1;i<lines.length;i++){
    const cols = splitCSVLine(lines[i]);
    const row = {};
    for (let j=0;j<headers.length;j++){
      row[headers[j]] = (cols[j] ?? "").trim();
    }
    rows.push(row);
  }
  return { headers, rows };
}
function pickCol(headers, candidates){
  const map = new Map(headers.map(h => [normHeader(h), h]));
  for (const c of candidates){
    const k = normHeader(c);
    if (map.has(k)) return map.get(k);
  }
  for (const [k, orig] of map.entries()){
    for (const c of candidates){
      if (k.includes(normHeader(c))) return orig;
    }
  }
  return null;
}
function niceStepX(span){
  if (span <= 10) return 1;
  if (span <= 20) return 2;
  if (span <= 40) return 5;
  return 10;
}
function niceStepY(span){
  if (span <= 2) return 0.2;
  if (span <= 5) return 0.5;
  if (span <= 10) return 1;
  if (span <= 20) return 2;
  if (span <= 50) return 5;
  if (span <= 100) return 10;
  if (span <= 200) return 20;
  if (span <= 500) return 50;
  return 100;
}
function computeXTicks(minYear, maxYear){
  const step = niceStepX(maxYear - minYear);
  const start = Math.ceil(minYear/step)*step;
  const out = [];
  for (let y=start; y<=maxYear+1e-9; y+=step) out.push(y);
  if (out[0] !== minYear) out.unshift(minYear);
  if (out[out.length-1] !== maxYear) out.push(maxYear);
  return Array.from(new Set(out)).sort((a,b)=>a-b);
}
function makeHSVColor(i, n){
  const h = (i / Math.max(1,n)) * 360;
  const s = 0.78, v = 0.98;
  const c = v * s;
  const x = c * (1 - Math.abs(((h/60) % 2) - 1));
  const m = v - c;
  let r=0,g=0,b=0;
  if (h < 60){ r=c; g=x; b=0; }
  else if (h < 120){ r=x; g=c; b=0; }
  else if (h < 180){ r=0; g=c; b=x; }
  else if (h < 240){ r=0; g=x; b=c; }
  else if (h < 300){ r=x; g=0; b=c; }
  else { r=c; g=0; b=x; }
  r = Math.round((r+m)*255);
  g = Math.round((g+m)*255);
  b = Math.round((b+m)*255);
  return `rgb(${r},${g},${b})`;
}

/* Curva suave Catmull-Rom -> Bézier (con clamping de overshoot) */
function buildSmoothPathFromPoints(pts){
  if (!pts || pts.length < 2) return "";
  function clampCtrlY(cy, y1, y2){
    const mn = Math.min(y1, y2);
    const mx = Math.max(y1, y2);
    const span = mx - mn;
    if (span < 1e-6) return cy;
    return clamp(cy, mn - 0.25*span, mx + 0.25*span);
  }
  let d = `M ${pts[0].x.toFixed(2)} ${pts[0].y.toFixed(2)}`;
  for (let i=0;i<pts.length-1;i++){
    const p0 = (i-1 >= 0) ? pts[i-1] : pts[i];
    const p1 = pts[i];
    const p2 = pts[i+1];
    const p3 = (i+2 < pts.length) ? pts[i+2] : p2;

    let c1x = p1.x + (p2.x - p0.x) / 6;
    let c1y = p1.y + (p2.y - p0.y) / 6;
    let c2x = p2.x - (p3.x - p1.x) / 6;
    let c2y = p2.y - (p3.y - p1.y) / 6;

    c1y = clampCtrlY(c1y, p1.y, p2.y);
    c2y = clampCtrlY(c2y, p1.y, p2.y);

    d += ` C ${c1x.toFixed(2)} ${c1y.toFixed(2)} ${c2x.toFixed(2)} ${c2y.toFixed(2)} ${p2.x.toFixed(2)} ${p2.y.toFixed(2)}`;
  }
  return d;
}

function lowerBound(arr, x){
  let lo=0, hi=arr.length;
  while (lo<hi){
    const mid = (lo+hi)>>1;
    if (arr[mid] < x) lo = mid+1;
    else hi = mid;
  }
  return lo;
}
function interpAtYear(series, year){
  const xs = series.xs;
  const ys = series.ys;
  if (!xs || xs.length === 0) return null;
  if (year < xs[0] || year > xs[xs.length-1]) return null;
  const i = lowerBound(xs, year);
  if (i < xs.length && xs[i] === year){
    const v = ys[i];
    return Number.isFinite(v) ? v : null;
  }
  const i1 = i;
  const i0 = i-1;
  if (i0 < 0 || i1 >= xs.length) return null;
  const x0 = xs[i0], x1 = xs[i1];
  const y0 = ys[i0], y1 = ys[i1];
  if (!Number.isFinite(y0) || !Number.isFinite(y1)) return null;
  const t = (year - x0) / (x1 - x0);
  return y0 + t * (y1 - y0);
}

/* ===================== Chart controller (SVG) ===================== */
function makeChartController(opts){
  const {
    svg, wrap, tooltipEl, errorEl,
    legendEl,
    controls,
    seriesList,
    getValueAtYear,
    getSeriesForPath,
    xDomain,
    yDomain,
    formatValue,
    extraBackground,
    yTickBuilder,
    rightAxis,
    yLabelLeft,
    yLabelRight,
    defaultOrderTooltip,
    topN,
    valueSorter,
  } = opts;

  const state = {
    focusSet: null,
    hoverKey: null,
    hoverFocusMode: false,
    crosshairMode: false,
    scaleMode: "exp",
    pathEls: new Map(),
    itemEls: new Map(),
    geom: null,
    rafPending: false,
    lastPointer: null,
    lastFocusKey: "",
  };

  function focusKey(set){
    if (!set || !set.size) return "";
    return Array.from(set).sort().join("|");
  }
  function getActiveFocusSet(){
    if (state.focusSet && state.focusSet.size) return state.focusSet;
    if (state.hoverFocusMode && state.hoverKey) return new Set([state.hoverKey]);
    return null;
  }
  function applyFocusStyles(force=false){
    const set = getActiveFocusSet();
    const key = focusKey(set);
    if (!force && key === state.lastFocusKey) return;
    state.lastFocusKey = key;

    const hasFocus = !!(set && set.size);
    for (const s of seriesList){
      const k = s.key;
      const path = state.pathEls.get(k);
      const it = state.itemEls.get(k);
      const on = !hasFocus || set.has(k);
      const baseOp = on ? 1.0 : 0.12;
      if (path){
        path.setAttribute("opacity", String(baseOp));
        path.setAttribute("stroke-width", on ? "2.35" : "1.6");
      }
      if (it){
        it.classList.toggle("muted", !on);
      }
    }
  }
  function toggleFocusKey(k, additive){
    if (!additive){
      if (state.focusSet && state.focusSet.size === 1 && state.focusSet.has(k)) state.focusSet = null;
      else state.focusSet = new Set([k]);
    } else {
      if (!state.focusSet) state.focusSet = new Set();
      if (state.focusSet.has(k)) state.focusSet.delete(k);
      else state.focusSet.add(k);
      if (state.focusSet.size === 0) state.focusSet = null;
    }
    applyFocusStyles(true);
  }

  function yTransform(v){
    if (!Number.isFinite(v)) return NaN;
    if (state.scaleMode === "log") return Math.log10(1 + Math.max(0, v));
    return v;
  }

  function computeYTicksLeft(ymax){
    if (yTickBuilder) return yTickBuilder("left", ymax);
    const step = niceStepY(ymax);
    const yTop = Math.ceil(ymax/step)*step;
    const out = [];
    for (let v=0; v<=yTop+1e-9; v+=step) out.push(v);
    return out;
  }

  function showError(msg){
    if (!errorEl) return;
    errorEl.style.display = "flex";
    errorEl.textContent = msg;
  }
  function hideError(){
    if (!errorEl) return;
    errorEl.style.display = "none";
    errorEl.textContent = "";
  }

  function buildLegend(){
    legendEl.innerHTML = "";
    state.itemEls.clear();

    for (const s of seriesList){
      const el = document.createElement("div");
      el.className = "item";
      el.dataset.key = s.key;

      const sw = document.createElement("div");
      sw.className = "sw";
      sw.style.background = s.color;

      const nm = document.createElement("div");
      nm.className = "nm";
      nm.textContent = s.label;

      el.appendChild(sw);
      el.appendChild(nm);

      if (s.badge){
        const bd = document.createElement("div");
        bd.className = "badge";
        bd.textContent = s.badge;
        el.appendChild(bd);
      }

      el.addEventListener("click", (ev) => {
        toggleFocusKey(s.key, ev.shiftKey);
      });

      legendEl.appendChild(el);
      state.itemEls.set(s.key, el);
    }
  }

  function draw(){
    hideError();
    const rect = wrap.getBoundingClientRect();
    const w = Math.max(320, Math.floor(rect.width));
    const h = Math.max(320, Math.floor(rect.height));

    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
    svg.setAttribute("preserveAspectRatio", "none");
    while (svg.firstChild) svg.removeChild(svg.firstChild);

    const margin = { l: 64, r: (yLabelRight ? 64 : 18), t: 18, b: 54 };
    const plotW = Math.max(10, w - margin.l - margin.r);
    const plotH = Math.max(10, h - margin.t - margin.b);
    const plotRect = { x: margin.l, y: margin.t, w: plotW, h: plotH };

    const xScale = (year) => {
      const t = (year - xDomain.min) / (xDomain.max - xDomain.min || 1);
      return margin.l + t * plotW;
    };

    const yTicksLeft = computeYTicksLeft(yDomain.left.max);
    const yValsT = yTicksLeft.map(v => yTransform(v));
    const yMinT = Math.min(...yValsT.filter(Number.isFinite));
    const yMaxT = Math.max(...yValsT.filter(Number.isFinite));
    const yScaleLeftT = (vT) => {
      const t = (vT - yMinT) / (yMaxT - yMinT || 1);
      return margin.t + plotH - t * plotH;
    };

    // Right axis mapping (optional)
    let mapRightToLeftT = null;
    let rightTicks = null;
    if (rightAxis){
      rightTicks = rightAxis.ticks;
      const rTicksT = rightTicks.map(v => yTransform(v)).filter(Number.isFinite);
      const rMinT = Math.min(...rTicksT);
      const rMaxT = Math.max(...rTicksT);
      mapRightToLeftT = (yrT) => {
        const alpha = (yrT - rMinT) / (rMaxT - rMinT || 1);
        return yMinT + alpha * (yMaxT - yMinT);
      };
    }

    const gBg = createSvgEl("g");
    const gGrid = createSvgEl("g");
    const gAxes = createSvgEl("g");
    const gLines = createSvgEl("g");
    const gOverlay = createSvgEl("g");

    if (extraBackground) extraBackground(gBg, xScale, plotRect);

    // Grid + x ticks
    const xTicks = computeXTicks(xDomain.min, xDomain.max);
    for (const yr of xTicks){
      const x = xScale(yr);
      gGrid.appendChild(createSvgEl("line", { x1:x, y1:margin.t, x2:x, y2:margin.t+plotH, stroke:"rgba(74,74,74,.38)", "stroke-width":1 }));
      const t = createSvgEl("text", { x:x, y: margin.t+plotH+18, fill:"rgba(176,176,176,.95)", "text-anchor":"middle", "font-size":12, "font-family":"Arial, system-ui, sans-serif" });
      t.textContent = yr;
      gAxes.appendChild(t);
    }
    // y ticks left
    for (const tv of yTicksLeft){
      const y = yScaleLeftT(yTransform(tv));
      gGrid.appendChild(createSvgEl("line", { x1:margin.l, y1:y, x2:margin.l+plotW, y2:y, stroke:"rgba(74,74,74,.38)", "stroke-width":1 }));
      const tx = createSvgEl("text", { x: margin.l-10, y: y+4, fill:"rgba(176,176,176,.95)", "text-anchor":"end", "font-size":12, "font-family":"Arial, system-ui, sans-serif" });
      tx.textContent = String(tv);
      gAxes.appendChild(tx);
    }

    // Right axis
    if (rightAxis){
      const rightX = margin.l + plotW;
      gAxes.appendChild(createSvgEl("line", { x1:rightX, y1:margin.t, x2:rightX, y2:margin.t+plotH, stroke:"rgba(176,176,176,.7)", "stroke-width":1.25 }));
      for (const tv of rightTicks){
        const yR = yTransform(tv);
        const yL = mapRightToLeftT(yR);
        const y = yScaleLeftT(yL);
        gGrid.appendChild(createSvgEl("line", { x1:rightX, y1:y, x2:rightX-8, y2:y, stroke:"rgba(176,176,176,.7)", "stroke-width":1 }));
        const tx = createSvgEl("text", { x: rightX+10, y: y+4, fill:"rgba(176,176,176,.95)", "text-anchor":"start", "font-size":12, "font-family":"Arial, system-ui, sans-serif" });
        tx.textContent = rightAxis.formatTick ? rightAxis.formatTick(tv) : String(tv);
        gAxes.appendChild(tx);
      }
    }

    // Axes base
    gAxes.appendChild(createSvgEl("line", { x1: margin.l, y1: margin.t+plotH, x2: margin.l+plotW, y2: margin.t+plotH, stroke:"rgba(176,176,176,.7)", "stroke-width":1.25 }));
    gAxes.appendChild(createSvgEl("line", { x1: margin.l, y1: margin.t, x2: margin.l, y2: margin.t+plotH, stroke:"rgba(176,176,176,.7)", "stroke-width":1.25 }));

    // Labels
    const xTitle = createSvgEl("text", { x: margin.l + plotW/2, y: margin.t+plotH+42, fill:"rgba(176,176,176,.95)", "text-anchor":"middle", "font-size":13, "font-family":"Arial, system-ui, sans-serif" });
    xTitle.textContent = "Año";
    gAxes.appendChild(xTitle);

    const yTitle = createSvgEl("text", {
      x: 18, y: margin.t + plotH/2, fill:"rgba(176,176,176,.95)",
      "text-anchor":"middle", "font-size":13, "font-family":"Arial, system-ui, sans-serif",
      transform: `rotate(-90 18 ${margin.t + plotH/2})`
    });
    yTitle.textContent = yLabelLeft || "";
    gAxes.appendChild(yTitle);

    if (yLabelRight){
      const rx = w - 18;
      const yTitleR = createSvgEl("text", {
        x: rx, y: margin.t + plotH/2, fill:"rgba(176,176,176,.95)",
        "text-anchor":"middle", "font-size":13, "font-family":"Arial, system-ui, sans-serif",
        transform: `rotate(90 ${rx} ${margin.t + plotH/2})`
      });
      yTitleR.textContent = yLabelRight;
      gAxes.appendChild(yTitleR);
    }

    // Lines
    state.pathEls.clear();
    for (const s of seriesList){
      const ser = getSeriesForPath(s.key);
      if (!ser || !ser.xs || ser.xs.length < 2) continue;

      const pts = [];
      for (let i=0;i<ser.xs.length;i++){
        const year = ser.xs[i];
        const v = ser.ys[i];
        if (!Number.isFinite(year) || !Number.isFinite(v)) continue;

        const x = xScale(year);

        let y;
        if (s.axis === "right" && rightAxis && mapRightToLeftT){
          const yrT = yTransform(v);
          const ylT = mapRightToLeftT(yrT);
          y = yScaleLeftT(ylT);
        } else {
          y = yScaleLeftT(yTransform(v));
        }

        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        pts.push({x,y});
      }
      if (pts.length < 2) continue;

      const d = buildSmoothPathFromPoints(pts);
      if (!d) continue;

      const path = createSvgEl("path", {
        d, fill:"none",
        stroke: s.color,
        "stroke-width": 2.0,
        "stroke-linejoin":"round",
        "stroke-linecap":"round",
        "vector-effect":"non-scaling-stroke",
        opacity: 1.0,
        "data-key": s.key,
        style: "pointer-events:none;"
      });
      state.pathEls.set(s.key, path);
      gLines.appendChild(path);
    }

    // Overlay
    const crosshair = createSvgEl("line", {
      x1: margin.l, y1: margin.t, x2: margin.l, y2: margin.t+plotH,
      stroke: "rgba(254,247,2,.55)", "stroke-width": 1.5,
      opacity: 0, "vector-effect":"non-scaling-stroke"
    });
    const dot = createSvgEl("circle", {
      cx: margin.l, cy: margin.t, r: 4.5,
      fill: "rgba(254,247,2,.95)", stroke: "rgba(0,0,0,.55)",
      "stroke-width": 1, opacity: 0
    });
    const hit = createSvgEl("rect", {
      x: margin.l, y: margin.t, width: plotW, height: plotH,
      fill: "rgba(0,0,0,0)", style: "cursor:crosshair;"
    });

    gOverlay.appendChild(crosshair);
    gOverlay.appendChild(dot);
    gOverlay.appendChild(hit);

    svg.appendChild(gBg);
    svg.appendChild(gGrid);
    svg.appendChild(gAxes);
    svg.appendChild(gLines);
    svg.appendChild(gOverlay);

    state.geom = { w,h, margin, plotW, plotH, xScale, yScaleLeftT, yTransform, mapRightToLeftT, crosshair, dot, hit };

    function localXY(ev){
      const b = svg.getBoundingClientRect();
      const x = (ev.clientX - b.left) * (w / b.width);
      const y = (ev.clientY - b.top) * (h / b.height);
      return {x,y};
    }
    function nearestYearFromX(x){
      const t = clamp((x - margin.l) / (plotW || 1), 0, 1);
      const year = Math.round(xDomain.min + t * (xDomain.max - xDomain.min));
      return clamp(year, xDomain.min, xDomain.max);
    }

    function renderHover(pt){
      const year = nearestYearFromX(pt.x);

      let hoverKey = null;
      let bestDist = Infinity;
      let bestY = null;

      for (const s of seriesList){
        const ser = getSeriesForPath(s.key);
        if (!ser) continue;
        const v = interpAtYear(ser, year);
        if (v === null) continue;

        let y;
        if (s.axis === "right" && rightAxis && state.geom.mapRightToLeftT){
          const yrT = yTransform(v);
          const ylT = state.geom.mapRightToLeftT(yrT);
          y = yScaleLeftT(ylT);
        } else {
          y = yScaleLeftT(yTransform(v));
        }

        const d = Math.abs(y - pt.y);
        if (d < bestDist){
          bestDist = d;
          hoverKey = s.key;
          bestY = y;
        }
      }

      state.hoverKey = hoverKey;

      if (state.crosshairMode){
        const x = xScale(year);
        crosshair.setAttribute("x1", x);
        crosshair.setAttribute("x2", x);
        crosshair.setAttribute("opacity", "1");
        dot.setAttribute("opacity", "0");

        // tooltip table
        const rows = [];
        const keys = (defaultOrderTooltip && defaultOrderTooltip.length) ? defaultOrderTooltip : seriesList.map(s=>s.key);
        for (const k of keys){
          const v = getValueAtYear(k, year);
          rows.push({ key:k, v });
        }

        let finalRows = rows;
        if (valueSorter){
          finalRows = rows.slice().sort(valueSorter);
        }
        if (Number.isFinite(topN) && topN > 0 && finalRows.length > topN){
          finalRows = finalRows.slice(0, topN);
        }

        tooltipEl.innerHTML = "";
        const yrEl = document.createElement("div");
        yrEl.className = "ttYear";
        yrEl.textContent = "Año " + year;
        tooltipEl.appendChild(yrEl);

        for (const r of finalRows){
          const s = seriesList.find(x => x.key === r.key);
          const row = document.createElement("div");
          row.className = "ttRow";
          const sw = document.createElement("div");
          sw.className = "ttSw";
          sw.style.background = s ? s.color : "rgba(255,255,255,.4)";
          const nm = document.createElement("div");
          nm.className = "ttName";
          nm.textContent = s ? s.label : r.key;
          const val = document.createElement("div");
          val.className = "ttVal";
          val.textContent = (r.v === null || !Number.isFinite(r.v)) ? "—" : formatValue(r.key, r.v);
          row.appendChild(sw);
          row.appendChild(nm);
          row.appendChild(val);
          tooltipEl.appendChild(row);
        }

        tooltipEl.style.display = "block";

        const pad = 10;
        let left = x + 12;
        let top = margin.t + 12;
        const tw = clamp(tooltipEl.offsetWidth || 260, 240, 420);
        const th = clamp(tooltipEl.offsetHeight || 180, 80, 420);
        if (left + tw + pad > w) left = x - tw - 12;
        if (top + th + pad > h) top = h - th - pad;
        tooltipEl.style.left = left + "px";
        tooltipEl.style.top = top + "px";

      } else {
        crosshair.setAttribute("opacity", "0");

        if (!hoverKey){
          tooltipEl.style.display = "none";
          dot.setAttribute("opacity", "0");
          applyFocusStyles(false);
          return;
        }

        const x = xScale(year);
        dot.setAttribute("cx", x);
        dot.setAttribute("cy", bestY);
        dot.setAttribute("opacity", "1");

        const s = seriesList.find(x => x.key === hoverKey);
        const v = getValueAtYear(hoverKey, year);
        tooltipEl.innerHTML = "";
        const yrEl = document.createElement("div");
        yrEl.className = "ttYear";
        yrEl.textContent = "Año " + year;
        tooltipEl.appendChild(yrEl);

        const row = document.createElement("div");
        row.className = "ttRow";
        const sw = document.createElement("div");
        sw.className = "ttSw";
        sw.style.background = s ? s.color : "rgba(255,255,255,.4)";
        const nm = document.createElement("div");
        nm.className = "ttName";
        nm.textContent = s ? s.label : hoverKey;
        const val = document.createElement("div");
        val.className = "ttVal";
        val.textContent = (v === null || !Number.isFinite(v)) ? "—" : formatValue(hoverKey, v);
        row.appendChild(sw);
        row.appendChild(nm);
        row.appendChild(val);
        tooltipEl.appendChild(row);

        tooltipEl.style.display = "block";
        let left = x + 12;
        let top = bestY - 14;
        const pad = 10;
        const tw = clamp(tooltipEl.offsetWidth || 260, 240, 420);
        const th = clamp(tooltipEl.offsetHeight || 120, 80, 420);
        if (left + tw + pad > w) left = x - tw - 12;
        top = clamp(top, margin.t + pad, h - th - pad);
        tooltipEl.style.left = left + "px";
        tooltipEl.style.top = top + "px";

        applyFocusStyles(false);
      }

      if (state.hoverFocusMode && !state.focusSet){
        applyFocusStyles(true);
      }
    }

    function onMove(ev){
      state.lastPointer = localXY(ev);
      if (state.rafPending) return;
      state.rafPending = true;
      requestAnimationFrame(() => {
        state.rafPending = false;
        if (!state.lastPointer) return;
        renderHover(state.lastPointer);
      });
    }
    function onLeave(){
      state.lastPointer = null;
      state.hoverKey = null;
      crosshair.setAttribute("opacity", "0");
      dot.setAttribute("opacity", "0");
      tooltipEl.style.display = "none";
      applyFocusStyles(true);
    }

    hit.addEventListener("mousemove", onMove);
    hit.addEventListener("mouseleave", onLeave);
    hit.addEventListener("click", (ev) => {
      if (state.hoverKey){
        toggleFocusKey(state.hoverKey, ev.shiftKey);
      }
    });

    applyFocusStyles(true);
  }

  function setControls(){
    controls.btnScale.addEventListener("click", () => {
      state.scaleMode = (state.scaleMode === "exp") ? "log" : "exp";
      controls.btnScale.textContent = "Escala: " + (state.scaleMode === "log" ? "Logarítmica" : "Exponencial");
      draw();
    });
    controls.btnCrosshair.addEventListener("click", () => {
      state.crosshairMode = !state.crosshairMode;
      controls.btnCrosshair.textContent = "Línea vertical: " + (state.crosshairMode ? "ON" : "OFF");
      controls.btnCrosshair.classList.toggle("on", state.crosshairMode);
      if (!state.crosshairMode){
        tooltipEl.style.display = "none";
      }
    });
    controls.btnHoverFocus.addEventListener("click", () => {
      state.hoverFocusMode = !state.hoverFocusMode;
      controls.btnHoverFocus.textContent = "Resaltar al pasar: " + (state.hoverFocusMode ? "ON" : "OFF");
      controls.btnHoverFocus.classList.toggle("on", state.hoverFocusMode);
      applyFocusStyles(true);
    });
    controls.btnReset.addEventListener("click", () => {
      state.focusSet = null;
      state.hoverKey = null;
      tooltipEl.style.display = "none";
      applyFocusStyles(true);
    });
  }

  buildLegend();
  setControls();
  draw();

  window.addEventListener("resize", () => {
    clearTimeout(state.__t);
    state.__t = setTimeout(() => draw(), 120);
  });

  return {
    onShow: () => draw(),
  };
}

/* ===================== Vista 1: PGE ===================== */
(async function(){
  const svg = document.getElementById("chartSvg");
  const wrap = document.getElementById("svgWrap");
  const tooltipEl = document.getElementById("tooltip");
  const errorEl = document.getElementById("errorBox");
  const legendEl = document.getElementById("legend");

  const controls = {
    btnScale: document.getElementById("btnScale"),
    btnCrosshair: document.getElementById("btnCrosshair"),
    btnHoverFocus: document.getElementById("btnHoverFocus"),
    btnReset: document.getElementById("btnResetFocus"),
  };
  const btnPre2004 = document.getElementById("btnPre2004");

  const app = {
    showPre2004: false,
    seriesByKey: new Map(),   // key -> {xs,ys} pct
    yearValueByKey: new Map(),// key -> Map(year->pct)
    keyInfo: new Map(),       // key -> {label,color,pre2004,peak}
    allKeys: [],
    xDomain: {min: 1986, max: 2023},
  };

  function formatPct(v){ return Number.isFinite(v) ? (v.toFixed(2) + "%") : "—"; }

  function buildSeriesList(){
    const keys = app.allKeys.slice();
    keys.sort((a,b)=> (app.keyInfo.get(b)?.peak||0) - (app.keyInfo.get(a)?.peak||0));

    const out = [];
    for (const k of keys){
      const info = app.keyInfo.get(k);
      if (!app.showPre2004 && info?.pre2004) continue;
      out.push({
        key: k,
        label: info?.label || k,
        color: info?.color || "rgba(176,176,176,.7)",
        badge: info?.pre2004 ? "pre-2004" : "",
        axis: "left"
      });
    }
    return out;
  }

  function computeYMax(keys){
    let ymax = 1;
    for (const k of keys){
      const ser = app.seriesByKey.get(k);
      if (!ser) continue;
      for (const v of ser.ys){
        if (Number.isFinite(v)) ymax = Math.max(ymax, v);
      }
    }
    return ymax;
  }

  function yTickBuilder(side, ymax){
    if (side !== "left") return [];
    if (ymax <= 10) return [0,1,2,3,4,5,6,8,10];
    if (ymax <= 20) return [0,2,4,6,8,10,12,15,20];
    if (ymax <= 40) return [0,5,10,15,20,25,30,35,40];
    if (ymax <= 60) return [0,10,20,30,40,50,60];
    return [0,10,20,30,40,50,60,80,100];
  }

  function getValueAtYear(key, year){
    const mp = app.yearValueByKey.get(key);
    if (!mp) return null;
    const v = mp.get(year);
    return Number.isFinite(v) ? v : null;
  }
  function getSeriesForPath(key){
    const info = app.keyInfo.get(key);
    if (!app.showPre2004 && info?.pre2004) return null;
    return app.seriesByKey.get(key) || null;
  }

  function tooltipSorter(a,b){
    const va = (a.v === null || !Number.isFinite(a.v)) ? -1 : a.v;
    const vb = (b.v === null || !Number.isFinite(b.v)) ? -1 : b.v;
    return vb - va;
  }

  async function loadPGE(){
    const [polTxt, m1Txt] = await Promise.all([
      fetchText("pge_politicas.csv"),
      fetchText("pge_politicas_metadata_1.csv").catch(() => ""),
    ]);

    const pol = parseCSV(polTxt);
    const headers = pol.headers;
    const cId = pickCol(headers, ["id_politica","id politica"]);
    const cYear = pickCol(headers, ["año","ano","anio","year"]);
    const cPol = pickCol(headers, ["politica","política","policy"]);
    const cVal = pickCol(headers, ["presupuesto","presupuesto gasto","valor","importe","amount"]);

    if (!cId || !cYear || !cPol || !cVal){
      throw new Error("pge_politicas.csv: faltan columnas requeridas (id, año, política, presupuesto).");
    }

    // meta name
    let idToName = new Map();
    if (m1Txt && m1Txt.trim()){
      const m1 = parseCSV(m1Txt);
      const mh = m1.headers;
      const mId = pickCol(mh, ["id_politica","id politica"]);
      const mPol = pickCol(mh, ["politica","política","policy"]);
      if (mId && mPol){
        for (const r of m1.rows){
          const id = String(r[mId] ?? "").trim();
          const nm = String(r[mPol] ?? "").trim();
          if (id && nm) idToName.set(id, nm);
        }
      }
    }

    const rows = [];
    for (const r of pol.rows){
      const id = String(r[cId] ?? "").trim();
      const year = Math.round(toNum(r[cYear]));
      const rawName = String(r[cPol] ?? "").trim();
      const name = idToName.get(id) || rawName || id;
      const val = toNum(r[cVal]);
      if (!id || !Number.isFinite(year) || !Number.isFinite(val)) continue;
      rows.push({ id, year, name, val });
    }
    if (!rows.length) throw new Error("pge_politicas.csv no tiene filas válidas.");

    const minYear = rows.reduce((m,r)=>Math.min(m,r.year), Infinity);
    const maxYear = rows.reduce((m,r)=>Math.max(m,r.year), -Infinity);
    app.xDomain = { min: minYear, max: maxYear };

    const totalByYear = new Map();
    for (const r of rows){
      totalByYear.set(r.year, (totalByYear.get(r.year)||0) + r.val);
    }

    const byKey = new Map();       // name -> Map(year->pct)
    const minYearByKey = new Map();// name -> minYear
    for (const r of rows){
      const tot = totalByYear.get(r.year) || 0;
      if (!(tot > 0)) continue;
      const pct = (r.val / tot) * 100;
      const key = r.name;

      if (!byKey.has(key)) byKey.set(key, new Map());
      byKey.get(key).set(r.year, pct);

      minYearByKey.set(key, Math.min(minYearByKey.get(key) ?? Infinity, r.year));
    }

    const keys = Array.from(byKey.keys());
    keys.sort((a,b)=> stripAccentsLower(a).localeCompare(stripAccentsLower(b)));

    const colorMap = new Map();
    for (let i=0;i<keys.length;i++){
      colorMap.set(keys[i], makeHSVColor(i, keys.length));
    }

    app.seriesByKey.clear();
    app.yearValueByKey.clear();
    app.keyInfo.clear();

    for (const k of keys){
      const mp = byKey.get(k);
      const xs = Array.from(mp.keys()).sort((a,b)=>a-b);
      const ys = xs.map(x => mp.get(x));
      app.seriesByKey.set(k, { xs, ys });
      app.yearValueByKey.set(k, mp);

      const minY = minYearByKey.get(k) ?? minYear;
      const pre2004 = minY < 2004;
      const peak = ys.reduce((m,v)=>Number.isFinite(v)?Math.max(m,v):m, 0);

      app.keyInfo.set(k, { label:k, color:colorMap.get(k), pre2004, peak });
    }
    app.allKeys = keys;
  }

  try{
    await loadPGE();
  } catch(e){
    errorEl.style.display = "flex";
    errorEl.textContent = e.message || String(e);
    window.__pge = { onShow: ()=>{} };
    return;
  }

  function rebuild(){
    const series = buildSeriesList();
    const yMax = computeYMax(series.map(s=>s.key));
    const controller = makeChartController({
      svg, wrap, tooltipEl, errorEl,
      legendEl,
      controls,
      seriesList: series,
      getValueAtYear,
      getSeriesForPath,
      xDomain: app.xDomain,
      yDomain: { left: { min:0, max:yMax } },
      formatValue: (k,v)=>formatPct(v),
      yTickBuilder,
      yLabelLeft: "Porcentaje del total (%)",
      yLabelRight: null,
      defaultOrderTooltip: null,
      topN: 15,
      valueSorter: (a,b)=>tooltipSorter(a,b)
    });
    window.__pge = { onShow: () => controller.onShow() };
  }

  btnPre2004.addEventListener("click", () => {
    app.showPre2004 = !app.showPre2004;
    btnPre2004.classList.toggle("on", app.showPre2004);
    rebuild();
  });

  rebuild();
})();

/* ===================== Vista 2: Gasto vs beneficio (PIB & Gasto) ===================== */
(async function(){
  const svg = document.getElementById("chartSvgGB");
  const wrap = document.getElementById("svgWrapGB");
  const tooltipEl = document.getElementById("tooltipGB");
  const errorEl = document.getElementById("errorBoxGB");
  const legendEl = document.getElementById("legendGB");

  const controls = {
    btnScale: document.getElementById("btnScaleGB"),
    btnCrosshair: document.getElementById("btnCrosshairGB"),
    btnHoverFocus: document.getElementById("btnHoverFocusGB"),
    btnReset: document.getElementById("btnResetFocusGB"),
  };

  const SERIES = [
    { key:"pib_total",  label:"PIB total",              color:"#00E5FF", axis:"left",  unit:"B€" },
    { key:"gasto_total",label:"Gasto público total",    color:"#FF6A00", axis:"left",  unit:"B€" },
    { key:"pib_pc",     label:"PIB per cápita",         color:"#79FF6B", axis:"right", unit:"k€" },
    { key:"gasto_pc",   label:"Gasto público per cápita",color:"#FF3D8D",axis:"right", unit:"k€" },
  ];

  const PRES = [
    { name:"Felipe González", start:1982, end:1996, color:"#552222" },
    { name:"José María Aznar", start:1996, end:2004, color:"#223C66" },
    { name:"José Luis Rodríguez Zapatero", start:2004, end:2011, color:"#552222" },
    { name:"Mariano Rajoy", start:2011, end:2018, color:"#223C66" },
    { name:"Pedro Sánchez", start:2018, end:null, color:"#552222" },
  ];

  const app = {
    xDomain: { min: 1986, max: 2023 },
    series: new Map(),      // key -> {xs,ys}
    yearVal: new Map(),     // key -> Map(year->v)
  };

  function formatVal(key, v){
    if (!Number.isFinite(v)) return "—";
    const s = SERIES.find(x => x.key === key);
    if (!s) return v.toFixed(1);
    if (s.unit === "B€") return v.toFixed(1) + " B€";
    if (s.unit === "k€") return v.toFixed(1) + " k€";
    return v.toFixed(1);
  }

  function getSeriesForPath(key){ return app.series.get(key) || null; }
  function getValueAtYear(key, year){
    const mp = app.yearVal.get(key);
    if (!mp) return null;
    const v = mp.get(year);
    return Number.isFinite(v) ? v : null;
  }

  function extraBackground(gBg, xScale, plotRect){
    for (const p of PRES){
      const x0 = Math.max(app.xDomain.min, p.start);
      const x1 = Math.min(app.xDomain.max, p.end ?? app.xDomain.max);
      if (x1 <= x0) continue;
      const x = xScale(x0);
      const w = xScale(x1) - xScale(x0);
      gBg.appendChild(createSvgEl("rect", {
        x, y: plotRect.y, width: w, height: plotRect.h,
        fill: p.color, opacity: 0.18
      }));
    }
  }

  async function loadGB(){
    const txt = await fetchText("indicadores_estado_a_1986.csv");
    const csv = parseCSV(txt);
    const h = csv.headers;

    const cYear = pickCol(h, ["anio","año","year"]);
    const cPIB  = pickCol(h, ["pib_total_eur_a_1986"]);
    const cGTO  = pickCol(h, ["gasto_publico_eur_a_1986"]);
    const cPIBPC= pickCol(h, ["pib_per_capita_eur_a_1986"]);
    const cGTOPC= pickCol(h, ["gasto_publico_per_capita_eur_a_1986"]);

    if (!cYear || !cPIB || !cGTO || !cPIBPC || !cGTOPC){
      throw new Error("indicadores_estado_a_1986.csv: faltan columnas requeridas para esta vista.");
    }

    const rows = [];
    for (const r of csv.rows){
      const year = Math.round(toNum(r[cYear]));
      if (!Number.isFinite(year)) continue;
      const pib = toNum(r[cPIB]);
      const gto = toNum(r[cGTO]);
      const pibpc = toNum(r[cPIBPC]);
      const gtopc = toNum(r[cGTOPC]);
      rows.push({ year, pib, gto, pibpc, gtopc });
    }
    if (!rows.length) throw new Error("indicadores_estado_a_1986.csv no tiene filas válidas.");

    const minY = rows.reduce((m,r)=>Math.min(m,r.year), Infinity);
    const maxY = rows.reduce((m,r)=>Math.max(m,r.year), -Infinity);
    app.xDomain = { min: Math.max(1986, minY), max: Math.min(2023, maxY) };

    const baseMaps = new Map(SERIES.map(s => [s.key, new Map()]));
    for (const r of rows){
      if (r.year < app.xDomain.min || r.year > app.xDomain.max) continue;
      baseMaps.get("pib_total").set(r.year, Number.isFinite(r.pib) ? r.pib/1e9 : NaN);
      baseMaps.get("gasto_total").set(r.year, Number.isFinite(r.gto) ? r.gto/1e9 : NaN);
      baseMaps.get("pib_pc").set(r.year, Number.isFinite(r.pibpc) ? r.pibpc/1000 : NaN);
      baseMaps.get("gasto_pc").set(r.year, Number.isFinite(r.gtopc) ? r.gtopc/1000 : NaN);
    }

    const years = [];
    for (let y=app.xDomain.min; y<=app.xDomain.max; y++) years.push(y);

    for (const s of SERIES){
      const ymap = baseMaps.get(s.key);
      const out = new Map();
      let last = null;
      for (const y of years){
        const v = ymap.get(y);
        if (v === undefined || v === null || !Number.isFinite(v)){
          out.set(y, (last === null) ? NaN : last);
        } else {
          out.set(y, v);
          last = v;
        }
      }
      app.yearVal.set(s.key, out);

      const xs = [];
      const ys = [];
      for (const y of years){
        const vv = out.get(y);
        if (Number.isFinite(vv)){
          xs.push(y);
          ys.push(vv);
        }
      }
      app.series.set(s.key, { xs, ys });
    }
  }

  try{
    await loadGB();
  } catch(e){
    errorEl.style.display = "flex";
    errorEl.textContent = e.message || String(e);
    window.__gb = { onShow: ()=>{} };
    return;
  }

  // y ranges
  const leftKeys = SERIES.filter(s=>s.axis==="left").map(s=>s.key);
  const rightKeys= SERIES.filter(s=>s.axis==="right").map(s=>s.key);

  let yLmax = 1, yRmax = 1;
  for (const k of leftKeys){
    const ser = app.series.get(k);
    if (!ser) continue;
    for (const v of ser.ys) if (Number.isFinite(v)) yLmax = Math.max(yLmax, v);
  }
  for (const k of rightKeys){
    const ser = app.series.get(k);
    if (!ser) continue;
    for (const v of ser.ys) if (Number.isFinite(v)) yRmax = Math.max(yRmax, v);
  }
  yLmax *= 1.06;
  yRmax *= 1.06;

  function buildTicks(maxV){
    const step = niceStepY(maxV);
    const top = Math.ceil(maxV/step)*step;
    const out = [];
    for (let v=0; v<=top+1e-9; v+=step) out.push(Number(v.toFixed(10)));
    return out;
  }

  const rightTicks = buildTicks(yRmax);

  const controller = makeChartController({
    svg, wrap, tooltipEl, errorEl,
    legendEl,
    controls,
    seriesList: SERIES.map(s => ({ key:s.key, label:s.label, color:s.color, axis:s.axis })),
    getValueAtYear,
    getSeriesForPath,
    xDomain: app.xDomain,
    yDomain: { left: { min: 0, max: yLmax } },
    formatValue: (k,v)=>formatVal(k,v),
    extraBackground,
    rightAxis: { ticks: rightTicks, formatTick: (v)=>String(v) },
    yLabelLeft: "Miles de millones de € (1986)",
    yLabelRight: "Miles de € por persona (1986)",
    defaultOrderTooltip: ["pib_total","gasto_total","pib_pc","gasto_pc"],
    topN: 0
  });

  window.__gb = { onShow: () => controller.onShow() };
})();

/* ===================== Vista 3: Poder adquisitivo ===================== */
(async function(){
  const svg = document.getElementById("chartSvgPA");
  const wrap = document.getElementById("svgWrapPA");
  const tooltipEl = document.getElementById("tooltipPA");
  const errorEl = document.getElementById("errorBoxPA");
  const legendEl = document.getElementById("legendPA");

  const controls = {
    btnScale: document.getElementById("btnScalePA"),
    btnCrosshair: document.getElementById("btnCrosshairPA"),
    btnHoverFocus: document.getElementById("btnHoverFocusPA"),
    btnReset: document.getElementById("btnResetFocusPA"),
  };

  const app = {
    xDomain: { min: 1986, max: 2023 },
    series: new Map(),
    yearVal: new Map(),
  };

  const KEY = "pct";
  const COLOR = "#FF3D8D";
  const LABEL = "Gasto público per cápita / PIB per cápita (1986)";

  function formatPct(v){
    if (!Number.isFinite(v)) return "—";
    return v.toFixed(1) + "%";
  }
  function getSeriesForPath(key){ return app.series.get(key) || null; }
  function getValueAtYear(key, year){
    const mp = app.yearVal.get(key);
    if (!mp) return null;
    const v = mp.get(year);
    return Number.isFinite(v) ? v : null;
  }

  async function loadPA(){
    const txt = await fetchText("indicadores_estado_a_1986.csv");
    const csv = parseCSV(txt);
    const h = csv.headers;

    const cYear = pickCol(h, ["anio","año","year"]);
    const cPct = pickCol(h, ["gasto_publico_per_capita_pct_1986"]);
    if (!cYear || !cPct){
      throw new Error("indicadores_estado_a_1986.csv: falta la columna gasto_publico_per_capita_pct_1986.");
    }

    const mp = new Map();
    const rows = [];
    for (const r of csv.rows){
      const year = Math.round(toNum(r[cYear]));
      const v = toNum(r[cPct]);
      if (!Number.isFinite(year) || !Number.isFinite(v)) continue;
      rows.push({year, v});
    }
    if (!rows.length) throw new Error("No hay datos válidos para poder adquisitivo.");

    const minY = Math.max(1986, rows.reduce((m,r)=>Math.min(m,r.year), Infinity));
    const maxY = Math.min(2023, rows.reduce((m,r)=>Math.max(m,r.year), -Infinity));
    app.xDomain = {min:minY, max:maxY};

    for (const r of rows){
      if (r.year < minY || r.year > maxY) continue;
      mp.set(r.year, r.v);
    }

    app.yearVal.set(KEY, mp);

    const xs = Array.from(mp.keys()).sort((a,b)=>a-b);
    const ys = xs.map(x => mp.get(x));
    app.series.set(KEY, { xs, ys });
  }

  try{
    await loadPA();
  } catch(e){
    errorEl.style.display = "flex";
    errorEl.textContent = e.message || String(e);
    window.__pa = { onShow: ()=>{} };
    return;
  }

  // legend
  legendEl.innerHTML = "";
  const it = document.createElement("div");
  it.className = "item";
  const sw = document.createElement("div"); sw.className="sw"; sw.style.background=COLOR;
  const nm = document.createElement("div"); nm.className="nm"; nm.textContent = LABEL;
  it.appendChild(sw); it.appendChild(nm);
  legendEl.appendChild(it);

  const ser = app.series.get(KEY);
  const ymax = Math.max(1, ...ser.ys.filter(Number.isFinite)) * 1.05;

  const controller = makeChartController({
    svg, wrap, tooltipEl, errorEl,
    legendEl,
    controls,
    seriesList: [{ key:KEY, label:LABEL, color:COLOR, axis:"left" }],
    getValueAtYear,
    getSeriesForPath,
    xDomain: app.xDomain,
    yDomain: { left: { min: 0, max: ymax } },
    formatValue: (k,v)=>formatPct(v),
    yLabelLeft: "Porcentaje del PIB per cápita (%)",
    yLabelRight: null,
    defaultOrderTooltip: [KEY],
    topN: 0
  });

  window.__pa = { onShow: () => controller.onShow() };
})();
</script>
</body>
</html>
