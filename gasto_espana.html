<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Presupuestos — % del gasto por política (España)</title>

  <!-- Plotly (puedes descargarlo y servirlo localmente si prefieres) -->
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>

  <style>
    :root{
      --uiScale: 1.35;

      --bg:#252525;
      --primary:#FEF702;
      --text:#B0B0B0;
      --grid:#4A4A4A;
      --panel:#2b2b2b;
      --stroke:#3a3a3a;

      --fontTitle: "Futura","Trebuchet MS",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      --fontText:  Arial,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;

      --radius:14px;
      --shadow: 0 10px 30px rgba(0,0,0,.25);
    }

    *{box-sizing:border-box}
    html, body{ height:100%; }

    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:var(--fontText);
      font-size: calc(14px * var(--uiScale));
    }

    header{
      padding:18px 18px 8px 18px;
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
    }
    .h-title{ line-height:1.05; }
    .h-title h1{
      margin:0;
      font-family:var(--fontTitle);
      color:var(--primary);
      font-size: calc(22px * var(--uiScale));
      letter-spacing:.3px;
    }
    .h-title p{ margin:6px 0 0 0; font-size: calc(13px * var(--uiScale)); opacity:.9; }

    .h-meta{
      font-size: calc(12px * var(--uiScale));
      opacity:.85;
      text-align:right;
      max-width:62ch;
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border:1px solid var(--stroke);
      border-radius:999px;
      background:rgba(255,255,255,.03);
      user-select:none;
    }
    .dot{
      width:8px; height:8px; border-radius:50%;
      background:var(--primary);
      box-shadow:0 0 0 3px rgba(254,247,2,.15);
    }
    a.back{
      color:var(--text);
      text-decoration:none;
      border-bottom:1px solid rgba(255,255,255,.18);
      padding-bottom:1px;
      white-space:nowrap;
    }
    a.back:hover{ border-bottom-color: rgba(254,247,2,.35); color:#fff; }

    main{
      height: calc(100vh - 70px);
      display:grid;
      grid-template-columns: 340px 1fr;
      gap:12px;
      padding:12px 12px 18px 12px;
      min-height:0;
    }

    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02));
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
      min-height:0;
    }
    .ph{
      padding:12px 12px 10px 12px;
      border-bottom:1px solid var(--stroke);
      background:rgba(255,255,255,.02);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      min-height:44px;
    }
    .ttl{
      font-family:var(--fontTitle);
      color:var(--primary);
      font-size: calc(13px * var(--uiScale));
      letter-spacing:.35px;
      text-transform:uppercase;
      white-space:nowrap;
      flex:0 0 auto;
    }
    .sub{
      font-size: calc(12px * var(--uiScale));
      opacity:.85;
      text-align:right;
      max-width:56ch;
      white-space:nowrap;
      flex:0 0 auto;
    }

    .pc{ padding:12px; min-height:0; height:100%; }

    .left{
      display:grid;
      grid-template-rows: 290px 1fr;
      gap:12px;
      min-height:0;
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row + .row{ margin-top:10px; }

    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.14);
      color:var(--text);
      border-radius:12px;
      padding:9px 10px;
      font-size: calc(12px * var(--uiScale));
      cursor:pointer;
      transition:.12s transform ease, .12s border-color ease, .12s color ease;
      white-space:nowrap;
      user-select:none;
    }
    .btn:hover{ border-color: rgba(254,247,2,.35); color:#fff; transform: translateY(-1px); }
    .btn.primary{
      border-color: rgba(254,247,2,.4);
      color: #111;
      background: rgba(254,247,2,.95);
    }
    .btn.primary:hover{ transform: translateY(-1px); border-color: rgba(254,247,2,.75); }
    .btn:disabled{ opacity:.5; cursor:not-allowed; transform:none; }

    .toggle{
      display:flex; align-items:center; gap:10px;
      font-size: calc(12px * var(--uiScale));
      opacity:.95;
      user-select:none;
    }
    .toggle input{ transform: scale(1.15); accent-color: var(--primary); }

    input[type="text"]{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.18);
      color:var(--text);
      outline:none;
      font-size: calc(12px * var(--uiScale));
    }
    input[type="text"]:focus{ border-color: rgba(254,247,2,.35); }

    .hint{
      font-size: calc(11px * var(--uiScale));
      opacity:.78;
      line-height:1.35;
      margin-top:8px;
    }

    .legend{
      display:flex;
      flex-direction:column;
      gap:8px;
      overflow:auto;
      height:100%;
      padding-right:4px;
    }
    .item{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      background: rgba(0,0,0,.10);
      cursor:pointer;
      user-select:none;
    }
    .item:hover{ border-color: rgba(254,247,2,.25); }
    .sw{ width:12px; height:12px; border-radius:3px; flex:0 0 auto; }
    .nm{
      flex:1 1 auto;
      font-size: calc(12px * var(--uiScale));
      line-height:1.15;
    }
    .badge{
      font-size: calc(10px * var(--uiScale));
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      opacity:.85;
      flex:0 0 auto;
    }
    .muted{ opacity:.35; }

    .chartWrap{
      height:100%;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    #plot{
      height:100%;
      min-height:0;
      width:100%;
    }

    .footer{
      padding:10px 12px;
      border-top:1px solid var(--stroke);
      display:flex;
      justify-content:space-between;
      font-size: calc(12px * var(--uiScale));
      opacity:.85;
    }

    .drop{
      border:1px dashed rgba(255,255,255,.18);
      border-radius:14px;
      padding:10px;
      background: rgba(255,255,255,.02);
    }
    .drop strong{ color:#fff; }
    .fileRow{ display:grid; grid-template-columns: 1fr; gap:8px; margin-top:8px; }
    .fileRow input[type="file"]{ width:100%; }

    @media (max-width: 900px){
      main{
        height:auto;
        grid-template-columns: 1fr;
      }
      .left{ grid-template-rows: auto auto; }
      #plot{ height: 520px; }
      header{ align-items:flex-start; flex-direction:column; }
      .h-meta{ text-align:left; }
    }
  </style>
</head>

<body>
  <header>
    <div class="h-title">
      <a class="back" href="index.html">← Inicio</a>
      <h1>Presupuestos generales del Estado — España</h1>
      <p>% del Presupuesto de Gasto por Política y Año</p>
    </div>

    <div class="h-meta">
      <div class="pill" id="statusPill" title="Estado de datos">
        <span class="dot"></span>
        <span id="statusText">Cargando datos…</span>
      </div>
      <div style="margin-top:8px;">
        Fuente: <span style="color:#fff">BOE</span> · <span style="opacity:.9;">N.Geolitics</span>
      </div>
    </div>
  </header>

  <main>
    <!-- IZQUIERDA -->
    <div class="left">
      <section class="panel">
        <div class="ph">
          <div class="ttl">Controles</div>
          <div class="sub" id="metaText">—</div>
        </div>
        <div class="pc">
          <div class="row">
            <button class="btn primary" id="btnFocusSS">Resaltar “Seguridad Social”</button>
            <button class="btn" id="btnFocusSE">Resaltar “Sanidad + Educación”</button>
            <button class="btn" id="btnReset">Reset</button>
          </div>

          <div class="row">
            <label class="toggle"><input type="checkbox" id="togX999" /> Mostrar detalle X999</label>
            <label class="toggle"><input type="checkbox" id="togOtros" checked /> Mostrar “otros”</label>
          </div>

          <div class="row">
            <button class="btn" id="btnStory">▶ Modo historia (como el vídeo)</button>
            <button class="btn" id="btnDownload">⬇ Descargar % (JSON)</button>
          </div>

          <div class="row">
            <input type="text" id="search" placeholder="Buscar política en la lista (ej. sanidad, educación, defensa…)" />
          </div>

          <div class="hint">
            <div>• Click en una política: activar/desactivar línea.</div>
            <div>• Doble click: foco (atenúa el resto).</div>
            <div>• “Modo historia”: resalta primero Seguridad Social y luego Sanidad+Educación (2s).</div>
          </div>

          <div class="drop" id="dropZone" style="margin-top:12px; display:none;">
            <strong>No encuentro los CSV.</strong><br/>
            Sube aquí los 3 ficheros (mismos nombres que usa tu script):
            <div class="fileRow">
              <input type="file" id="fPol" accept=".csv,text/csv" />
              <input type="file" id="fMeta1" accept=".csv,text/csv" />
              <input type="file" id="fMeta2" accept=".csv,text/csv" />
              <button class="btn" id="btnUseFiles">Usar ficheros subidos</button>
            </div>
            <div class="hint">Esperados: <code>pge_politicas.csv</code>, <code>pge_politicas_metadata_1.csv</code>, <code>pge_politicas_metadata_2.csv</code>.</div>
          </div>
        </div>
      </section>

      <section class="panel">
        <div class="ph">
          <div class="ttl">Políticas</div>
          <div class="sub"><span id="countText">—</span></div>
        </div>
        <div class="pc" style="padding:12px; height:100%; min-height:0;">
          <div class="legend" id="legend"></div>
        </div>
      </section>
    </div>

    <!-- DERECHA -->
    <section class="panel">
      <div class="ph">
        <div class="ttl">Gráfico</div>
        <div class="sub">(% del total anual; suma visible ≈ 100%)</div>
      </div>
      <div class="pc chartWrap">
        <div id="plot"></div>
        <div class="footer">
          <div>Fuente: BOE</div>
          <div>N.Geolitics</div>
        </div>
      </div>
    </section>
  </main>

<script>
/* ===========================
   Utilidades (normalización)
   =========================== */
const PALETTE = { bg:"#252525", primary:"#FEF702", text:"#B0B0B0", grid:"#4A4A4A" };

function stripAccentsLower(s){
  if (s === null || s === undefined) return "";
  return String(s)
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .replace(/\s+/g, " ")
    .trim();
}
function normHeader(s){
  return stripAccentsLower(s)
    .replace(/[\s_\t\u00a0]/g,"")
    .replace(/ó/g,"o").replace(/á/g,"a").replace(/é/g,"e")
    .replace(/í/g,"i").replace(/ú/g,"u").replace(/ñ/g,"n");
}
function pickCol(cols, candidates, required=true){
  const norm = new Map(cols.map(c => [normHeader(c), c]));
  for (const cand of candidates){
    const key = normHeader(cand);
    if (norm.has(key)) return norm.get(key);
  }
  if (required) throw new Error("No se encontró ninguna de las columnas: " + candidates.join(", "));
  return null;
}
function toNumber(x){
  if (x === null || x === undefined) return NaN;
  if (typeof x === "number") return x;
  const s = String(x).trim()
    .replace(/\./g, "")      // miles tipo 1.234.567
    .replace(",", ".");      // decimal con coma
  const v = Number(s);
  return Number.isFinite(v) ? v : NaN;
}
function sortKeyId(idv){
  const s = String(idv ?? "").trim();
  let m = s.match(/^0*(\d+)$/);
  if (m) return [0, Number(m[1]), s];
  m = s.match(/^[xX](\d+)$/);
  if (m) return [1, Number(m[1]), s];
  return [2, 0, s];
}
function hsvToHex(h,s,v){
  // h in [0,1)
  let r=0,g=0,b=0;
  const i = Math.floor(h*6);
  const f = h*6 - i;
  const p = v*(1-s);
  const q = v*(1-f*s);
  const t = v*(1-(1-f)*s);
  switch(i%6){
    case 0: r=v; g=t; b=p; break;
    case 1: r=q; g=v; b=p; break;
    case 2: r=p; g=v; b=t; break;
    case 3: r=p; g=q; b=v; break;
    case 4: r=t; g=p; b=v; break;
    case 5: r=v; g=p; b=q; break;
  }
  const toHex = (x)=> {
    const n = Math.max(0, Math.min(255, Math.round(x*255)));
    return n.toString(16).padStart(2,"0");
  };
  return "#" + toHex(r)+toHex(g)+toHex(b);
}
function colorList(n){
  if (n<=0) return [];
  const cols=[];
  for (let i=0;i<n;i++){
    cols.push(hsvToHex(i/n, 0.9, 1.0));
  }
  return cols;
}

/* ===========================
   CSV parsing (simple + robust)
   =========================== */
function splitCSVLine(line, sep){
  const out = [];
  let cur = "";
  let inQ = false;
  for (let i=0;i<line.length;i++){
    const ch = line[i];
    if (ch === '"'){
      if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
      else inQ = !inQ;
    } else if (!inQ && ch === sep){
      out.push(cur);
      cur = "";
    } else {
      cur += ch;
    }
  }
  out.push(cur);
  return out;
}
function detectSep(firstLine){
  const seps = [",",";","\t","|"];
  let best = ",";
  let bestCount = 1;
  for (const s of seps){
    const parts = splitCSVLine(firstLine, s);
    if (parts.length > bestCount){
      bestCount = parts.length;
      best = s;
    }
  }
  return best;
}
function parseCSV(text){
  // Normaliza saltos y elimina BOM
  text = text.replace(/^\uFEFF/, "");
  const lines = text.split(/\r?\n/).filter(l => l.trim().length>0);
  if (!lines.length) return { cols:[], rows:[] };
  const sep = detectSep(lines[0]);
  const rawCols = splitCSVLine(lines[0], sep).map(c => c.replace(/\u00a0/g," ").trim());
  const cols = rawCols;
  const rows = [];
  for (let i=1;i<lines.length;i++){
    const parts = splitCSVLine(lines[i], sep);
    const obj = {};
    for (let j=0;j<cols.length;j++){
      obj[cols[j]] = (parts[j] ?? "").replace(/\u00a0/g," ").trim();
    }
    rows.push(obj);
  }
  return { cols, rows };
}

async function fetchText(url){
  const res = await fetch(url, { cache:"no-store" });
  if (!res.ok) throw new Error("HTTP " + res.status + " al cargar " + url);
  return await res.text();
}

async function readFileAsText(file){
  const buf = await file.arrayBuffer();
  let txt = new TextDecoder("utf-8", { fatal:false }).decode(buf);
  // heurística: si hay muchos �, probar cp1252
  const bad = (txt.match(/\uFFFD/g) || []).length;
  if (bad > 10){
    txt = new TextDecoder("windows-1252", { fatal:false }).decode(buf);
  }
  return txt;
}

/* ===========================
   Lógica del script (preparar_series_pct) en JS
   =========================== */
const PENSIONS_LABEL = "Pensiones";
const PENSIONS_PATTERNS = new Set(["pensiones"]);
const OTROS_LABEL = "otros";

const OLD31_EQUIV_LABEL = "Seguridad Social";
const OLD31_CUTOFF_YEAR = 2005;
const OLD31_POST2005_IDS = new Set(["21","22","23","25","29"]);
const OLD31_POST2005_NAME_PATTERNS = new Set([
  "pensiones",
  "otras prestaciones economicas",
  "servicios sociales y promocion social",
  "desempleo",
]);
const OLD31_PRE2005_NAMES = new Set([
  "seguridad social y proteccion social",
  "seguridad y proteccion social",
]);

function isGestionSS(nameNorm){
  return nameNorm.includes("gestion") && nameNorm.includes("seguridad social");
}

function findFocusLabel(labels){
  for (const lab of labels){
    if (stripAccentsLower(lab).includes("seguridad social")) return lab;
  }
  for (const lab of labels){
    if (stripAccentsLower(lab).includes("pension")) return lab;
  }
  return null;
}
function findLabelByKeywords(labels, keywords){
  const normLabels = labels.map(l => [l, stripAccentsLower(l)]);
  const normKW = (keywords||[]).map(k => stripAccentsLower(k)).filter(Boolean);
  for (const [lab, nlab] of normLabels){
    for (const kw of normKW){
      if (kw && nlab.includes(kw)) return lab;
    }
  }
  return null;
}

function prepararSeriesPct(dfPol, dfMeta1 /* dfMeta2 reservado */){
  const colsPol = dfPol.cols;
  const rowsPol = dfPol.rows;

  const c_id   = pickCol(colsPol, ["id_politica", "id politica"]);
  const c_year = pickCol(colsPol, ["año","ano","anio","year"]);
  const c_pol  = pickCol(colsPol, ["politica","política"]);
  const c_val  = pickCol(colsPol, ["presupuesto","presupuesto gasto","valor","importe"]);

  // normaliza rows base
  const base = [];
  for (const r of rowsPol){
    const id = String(r[c_id] ?? "").trim();
    const year = toNumber(r[c_year]);
    const pol = String(r[c_pol] ?? "").trim();
    const val = toNumber(r[c_val]);
    if (!id || !Number.isFinite(year) || !pol || !Number.isFinite(val)) continue;
    base.push({
      id,
      year: Math.trunc(year),
      pol,
      val,
      pol_norm: stripAccentsLower(pol),
      id_norm: String(id).trim(),
    });
  }
  if (!base.length) return null;

  // meta1: id -> nombre (ordenado por id)
  const colsM1 = dfMeta1.cols;
  const rowsM1 = dfMeta1.rows;
  const c_m1_id  = pickCol(colsM1, ["id_politica"]);
  const c_m1_pol = pickCol(colsM1, ["politica","política"]);

  const meta1_sorted = rowsM1
    .map(r => ({ id: String(r[c_m1_id] ?? "").trim(), pol: String(r[c_m1_pol] ?? "").trim() }))
    .filter(r => r.id && r.pol)
    .sort((a,b)=>{
      const ka = sortKeyId(a.id);
      const kb = sortKeyId(b.id);
      return ka[0]-kb[0] || ka[1]-kb[1] || ka[2].localeCompare(kb[2]);
    });

  const id_to_name = new Map();
  for (const row of meta1_sorted){
    const idp = row.id;
    const nm = row.pol;
    if (!idp || idp === "X999") continue;
    const nm_norm = stripAccentsLower(nm);
    const label = (PENSIONS_PATTERNS.has(nm_norm) || idp === "05") ? PENSIONS_LABEL : nm;
    if (!id_to_name.has(idp)) id_to_name.set(idp, label);
  }

  function clasificar(idp, pol_name){
    idp = String(idp ?? "").trim();
    pol_name = String(pol_name ?? "").trim();
    const pol_norm = stripAccentsLower(pol_name);

    if (PENSIONS_PATTERNS.has(pol_norm) || idp === "05") return [PENSIONS_LABEL, "main"];
    if (id_to_name.has(idp)) return [id_to_name.get(idp), "main"];
    if (idp === "X999"){
      const label = pol_name ? pol_name : OTROS_LABEL;
      return [label, "x999"];
    }
    return [OTROS_LABEL, "otros"];
  }

  // agrega por (Label, Año)
  const gMap = new Map(); // key = label||year
  const labelTipo = new Map();
  for (const r of base){
    const [lab, tp] = clasificar(r.id, r.pol);
    const key = lab + "||" + r.year;
    gMap.set(key, (gMap.get(key) || 0) + r.val);
    if (!labelTipo.has(lab)) labelTipo.set(lab, tp);
  }

  // convierte a array g
  let g = [];
  for (const [key, sum] of gMap.entries()){
    const [lab, y] = key.split("||");
    const year = Number(y);
    const lab_norm = stripAccentsLower(lab);
    g.push({
      Label: lab,
      Año: year,
      Valor: sum,
      Label_norm: lab_norm,
      __is_gestion_ss: isGestionSS(lab_norm),
    });
  }

  // 1) ocultar componentes desde 2005
  g = g.filter(row => {
    if (row.Año < OLD31_CUTOFF_YEAR) return true;
    const ln = row.Label_norm;
    const isComp = (ln === "pensiones") || OLD31_POST2005_NAME_PATTERNS.has(ln) || row.__is_gestion_ss;
    return !isComp;
  });

  // 2) ocultar vieja 31 pre-2005
  g = g.filter(row => {
    if (row.Año >= OLD31_CUTOFF_YEAR) return true;
    return !OLD31_PRE2005_NAMES.has(row.Label_norm);
  });

  // 3) serie compuesta Seguridad Social
  // PRE-2005: usa nombres antiguos
  const preMap = new Map();
  for (const r of base){
    if (r.year < OLD31_CUTOFF_YEAR && OLD31_PRE2005_NAMES.has(r.pol_norm)){
      preMap.set(r.year, (preMap.get(r.year)||0) + r.val);
    }
  }
  // POST-2005: suma IDs 21/22/23/25/29 o nombres equivalentes o gestión SS
  const postMap = new Map();
  for (const r of base){
    if (r.year >= OLD31_CUTOFF_YEAR){
      const isPost = OLD31_POST2005_IDS.has(r.id_norm) ||
                     OLD31_POST2005_NAME_PATTERNS.has(r.pol_norm) ||
                     isGestionSS(r.pol_norm);
      if (isPost){
        postMap.set(r.year, (postMap.get(r.year)||0) + r.val);
      }
    }
  }

  const comp = [];
  for (const [year,val] of preMap.entries()) comp.push({ Label: OLD31_EQUIV_LABEL, Año: year, Valor: val });
  for (const [year,val] of postMap.entries()) comp.push({ Label: OLD31_EQUIV_LABEL, Año: year, Valor: val });
  comp.sort((a,b)=>a.Año-b.Año);

  // g2 = g + comp
  const g2 = g.map(r => ({ Label:r.Label, Año:r.Año, Valor:r.Valor })).concat(comp);

  // totales anuales del DF original (base)
  const totMap = new Map();
  for (const r of base){
    totMap.set(r.year, (totMap.get(r.year)||0) + r.val);
  }

  // pct rows
  const pctRows = [];
  for (const r of g2){
    const total = totMap.get(r.Año) || NaN;
    if (!Number.isFinite(total) || total === 0) continue;
    pctRows.push({
      Label: r.Label,
      Año: r.Año,
      Porcentaje: (r.Valor/total)*100,
    });
  }

  // legend_labels desde meta1, unificando Pensiones
  const legend_labels = [];
  for (const row of meta1_sorted){
    const idp = row.id;
    const nm = row.pol;
    if (!idp || idp === "X999") continue;
    const nm_norm = stripAccentsLower(nm);
    const lab = (PENSIONS_PATTERNS.has(nm_norm) || idp === "05") ? PENSIONS_LABEL : nm;
    if (!legend_labels.includes(lab)) legend_labels.push(lab);
  }
  if (!legend_labels.includes(OLD31_EQUIV_LABEL)) legend_labels.push(OLD31_EQUIV_LABEL);
  if (!legend_labels.includes(OTROS_LABEL)) legend_labels.push(OTROS_LABEL);

  const labelsExist = new Set(pctRows.map(r => r.Label));
  const labels_main = legend_labels.filter(lab => labelsExist.has(lab) || lab === OTROS_LABEL);

  // x999 labels
  const x999_labels = Array.from(labelTipo.entries())
    .filter(([lab,tp]) => tp === "x999")
    .map(([lab,_]) => lab)
    .sort((a,b)=>a.localeCompare(b, "es"));

  // series por label
  const byLabel = new Map();
  for (const r of pctRows){
    if (!byLabel.has(r.Label)) byLabel.set(r.Label, []);
    byLabel.get(r.Label).push([r.Año, r.Porcentaje]);
  }
  const series = new Map();
  let allYears = new Set();
  let yMax = 1.0;

  for (const [lab, pts] of byLabel.entries()){
    pts.sort((a,b)=>a[0]-b[0]);
    if (pts.length < 2) continue;
    const xs = pts.map(p=>p[0]);
    const ys = pts.map(p=>p[1]);
    xs.forEach(y=>allYears.add(y));
    ys.forEach(v=>{ if (Number.isFinite(v)) yMax = Math.max(yMax, v); });
    series.set(lab, { xs, ys });
  }

  const years = Array.from(allYears).sort((a,b)=>a-b);
  return { series, labels_main, x999_labels, years, y_max_pct: yMax };
}

/* ===========================
   UI + Plotly
   =========================== */
const els = {
  statusText: document.getElementById("statusText"),
  statusPill: document.getElementById("statusPill"),
  legend: document.getElementById("legend"),
  countText: document.getElementById("countText"),
  metaText: document.getElementById("metaText"),
  search: document.getElementById("search"),
  togX999: document.getElementById("togX999"),
  togOtros: document.getElementById("togOtros"),
  btnFocusSS: document.getElementById("btnFocusSS"),
  btnFocusSE: document.getElementById("btnFocusSE"),
  btnReset: document.getElementById("btnReset"),
  btnStory: document.getElementById("btnStory"),
  btnDownload: document.getElementById("btnDownload"),
  dropZone: document.getElementById("dropZone"),
  fPol: document.getElementById("fPol"),
  fMeta1: document.getElementById("fMeta1"),
  fMeta2: document.getElementById("fMeta2"),
  btnUseFiles: document.getElementById("btnUseFiles"),
};

let app = {
  prepared: null,
  traceIndexByLabel: new Map(),
  labelsMain: [],
  x999Labels: [],
  focusSet: null,
  showX999: false,
  showOtros: true,
};

function setStatus(txt, ok=true){
  els.statusText.textContent = txt;
  els.statusPill.style.borderColor = ok ? "rgba(254,247,2,.35)" : "rgba(255,90,90,.55)";
  els.statusPill.querySelector(".dot").style.background = ok ? "var(--primary)" : "rgba(255,90,90,1)";
}

function niceStepX(span){
  if (span <= 10) return 1;
  if (span <= 20) return 2;
  if (span <= 40) return 5;
  return 10;
}
function niceStepY(ymax){
  if (ymax <= 20) return 2;
  if (ymax <= 50) return 5;
  return 10;
}

function buildPlot(prep){
  app.prepared = prep;
  const { series, labels_main, x999_labels, years, y_max_pct } = prep;
  app.labelsMain = labels_main;
  app.x999Labels = x999_labels;

  const minYear = years[0], maxYear = years[years.length-1];
  const xStep = niceStepX(maxYear - minYear);
  const yMaxPlot = Math.max(10, Math.ceil(y_max_pct/5)*5);
  const yStep = niceStepY(yMaxPlot);

  els.metaText.textContent = `${minYear}–${maxYear} · ${labels_main.length} políticas (+X999: ${x999_labels.length})`;

  // colores como en el script
  const cols = colorList(labels_main.length);
  const color_map = new Map(labels_main.map((lab,i)=>[lab, cols[i]]));
  const otrosColor = color_map.get(OTROS_LABEL) || PALETTE.text;

  // construye traces
  const traces = [];
  app.traceIndexByLabel = new Map();
  let idx = 0;

  for (const [lab, data] of series.entries()){
    const isMain = labels_main.includes(lab);
    const isOtros = (lab === OTROS_LABEL);
    const isX999 = x999_labels.includes(lab);

    let color = otrosColor;
    if (isMain && !isOtros) color = color_map.get(lab) || otrosColor;

    // visibilidad inicial
    let visible = true;
    if (isX999) visible = false; // por defecto, oculto
    if (isOtros && !app.showOtros) visible = false;

    traces.push({
      type: "scatter",
      mode: "lines",
      name: lab,
      x: data.xs,
      y: data.ys,
      line: { width: 2, color },
      opacity: 1,
      visible: visible ? true : "legendonly",
      hovertemplate: `<b>%{x}</b><br>${lab}: <b>%{y:.2f}%</b><extra></extra>`,
      showlegend: false, // usamos nuestra leyenda propia
    });

    app.traceIndexByLabel.set(lab, idx++);
  }

  const layout = {
    margin: { l: 60, r: 20, t: 20, b: 55 },
    paper_bgcolor: "rgba(0,0,0,0)",
    plot_bgcolor: "rgba(0,0,0,0)",
    font: { color: PALETTE.text, family: "Arial, system-ui, sans-serif" },
    xaxis: {
      title: { text: "Año", standoff: 10 },
      range: [minYear, maxYear],
      tick0: minYear,
      dtick: xStep,
      gridcolor: "rgba(74,74,74,.45)",
      zeroline: false,
      showline: true,
      linecolor: "rgba(176,176,176,.7)",
      tickfont: { color: PALETTE.text },
      titlefont: { color: PALETTE.text },
    },
    yaxis: {
      title: { text: "Porcentaje del total (%)", standoff: 12 },
      range: [0, yMaxPlot],
      dtick: yStep,
      gridcolor: "rgba(74,74,74,.45)",
      zeroline: false,
      showline: true,
      linecolor: "rgba(176,176,176,.7)",
      tickfont: { color: PALETTE.text },
      titlefont: { color: PALETTE.text },
    },
  };

  const config = {
    displayModeBar: true,
    responsive: true,
    scrollZoom: true,
  };

  Plotly.newPlot("plot", traces, layout, config).then(()=>{
    buildLegendUI(color_map, otrosColor);
    applyVisibilityToggles(); // por si toggles iniciales
    setStatus("Datos listos", true);
  });
}

function buildLegendUI(color_map, otrosColor){
  els.legend.innerHTML = "";
  const { labels_main, x999_labels } = app.prepared;

  const items = [];
  for (const lab of labels_main){
    // Solo mostramos main + otros (como en Manim)
    if (lab !== OTROS_LABEL && !app.traceIndexByLabel.has(lab)) continue;

    const color = (lab === OTROS_LABEL) ? otrosColor : (color_map.get(lab) || otrosColor);
    const el = document.createElement("div");
    el.className = "item";
    el.dataset.label = lab;

    el.innerHTML = `
      <span class="sw" style="background:${color}"></span>
      <span class="nm">${lab}</span>
      <span class="badge" title="Click: mostrar/ocultar · Doble click: foco">main</span>
    `;

    el.addEventListener("click", ()=> toggleTrace(lab, el));
    el.addEventListener("dblclick", (e)=>{ e.preventDefault(); setFocus(new Set([lab])); });

    items.push(el);
  }

  // contador
  els.countText.textContent = `${items.length} (main) · X999: ${x999_labels.length}`;
  items.forEach(el => els.legend.appendChild(el));
}

function getTraceVisible(idx){
  const gd = document.getElementById("plot");
  const v = gd.data[idx].visible;
  return (v === true || v === undefined);
}
function setTraceVisible(idx, on){
  const vis = on ? true : "legendonly";
  Plotly.restyle("plot", { visible: vis }, [idx]);
}

function toggleTrace(label, el){
  const idx = app.traceIndexByLabel.get(label);
  if (idx === undefined) return;
  const on = getTraceVisible(idx);
  setTraceVisible(idx, !on);
  el.classList.toggle("muted", on);
}

function setFocus(setLabels){
  // focus mode como en el script: foco => resto atenuado
  app.focusSet = setLabels;

  const gd = document.getElementById("plot");
  const inactiveOpacity = 0.15;
  const inactiveWidth = 1.5;
  const activeWidth = 3.0;
  const normalWidth = 2.0;

  const upd = { "line.width": [], "opacity": [] };
  const idxs = [];

  gd.data.forEach((tr, i)=>{
    const lab = tr.name;
    const isFocus = setLabels && setLabels.has(lab);
    idxs.push(i);
    if (!setLabels){
      upd["line.width"].push(normalWidth);
      upd["opacity"].push(1.0);
    } else if (isFocus){
      upd["line.width"].push(activeWidth);
      upd["opacity"].push(1.0);
    } else {
      upd["line.width"].push(inactiveWidth);
      upd["opacity"].push(inactiveOpacity);
    }
  });

  Plotly.restyle("plot", upd, idxs);

  // marca UI
  document.querySelectorAll(".item").forEach(it=>{
    const lab = it.dataset.label;
    if (!setLabels){
      it.classList.remove("muted");
    } else {
      it.classList.toggle("muted", !setLabels.has(lab));
    }
  });
}

function resetFocus(){
  setFocus(null);
}

function applyVisibilityToggles(){
  const { x999_labels } = app.prepared;
  const showX999 = !!els.togX999.checked;
  const showOtros = !!els.togOtros.checked;
  app.showX999 = showX999;
  app.showOtros = showOtros;

  // X999 traces
  for (const lab of x999_labels){
    const idx = app.traceIndexByLabel.get(lab);
    if (idx === undefined) continue;
    Plotly.restyle("plot", { visible: showX999 ? true : "legendonly" }, [idx]);
  }

  // otros
  const idxOtros = app.traceIndexByLabel.get(OTROS_LABEL);
  if (idxOtros !== undefined){
    Plotly.restyle("plot", { visible: showOtros ? true : "legendonly" }, [idxOtros]);
    // también atenúa el item si está oculto
    const item = document.querySelector(`.item[data-label="${OTROS_LABEL}"]`);
    if (item) item.classList.toggle("muted", !showOtros);
  }
}

function downloadJSON(){
  const { series, labels_main, x999_labels, years, y_max_pct } = app.prepared;
  const out = {
    title: "Presupuestos generales del Estado — España",
    subtitle: "% del Presupuesto de Gasto por Política y Año",
    cutOffYear: OLD31_CUTOFF_YEAR,
    series: Array.from(series.entries()).map(([label, d]) => ({
      label,
      points: d.xs.map((x,i)=>({ year:x, pct:d.ys[i] }))
    })),
    labels_main,
    x999_labels,
    years,
    y_max_pct,
  };

  const blob = new Blob([JSON.stringify(out, null, 2)], { type:"application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "pge_series_pct.json";
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

async function storyMode(){
  if (!app.prepared) return;
  els.btnStory.disabled = true;

  const allLabels = Array.from(app.prepared.series.keys());
  const focusSS = findFocusLabel(allLabels);
  const focusSan = findLabelByKeywords(allLabels, ["sanidad","salud"]);
  const focusEdu = findLabelByKeywords(allLabels, ["educacion","enseñanza","ensenanza"]);

  if (focusSS) setFocus(new Set([focusSS]));
  await new Promise(r=>setTimeout(r, 2000));
  const next = [focusSan, focusEdu].filter(l => l && app.traceIndexByLabel.has(l));
  if (next.length) setFocus(new Set(next));
  await new Promise(r=>setTimeout(r, 2000));

  els.btnStory.disabled = false;
}

function applySearch(){
  const q = stripAccentsLower(els.search.value);
  document.querySelectorAll(".item").forEach(it=>{
    const lab = it.dataset.label || "";
    const ok = !q || stripAccentsLower(lab).includes(q);
    it.style.display = ok ? "" : "none";
  });
}

async function loadDataDefault(){
  // mismos nombres que usa tu script (puedes cambiarlos aquí si quieres)
  const polUrl = "pge_politicas.csv";
  const meta1Url = "pge_politicas_metadata_1.csv";
  const meta2Url = "pge_politicas_metadata_2.csv";

  try{
    const [polTxt, m1Txt, m2Txt] = await Promise.all([
      fetchText(polUrl),
      fetchText(meta1Url),
      fetchText(meta2Url),
    ]);
    const dfPol = parseCSV(polTxt);
    const dfM1 = parseCSV(m1Txt);
    const dfM2 = parseCSV(m2Txt);

    const prep = prepararSeriesPct(dfPol, dfM1, dfM2);
    if (!prep) throw new Error("Los CSV se cargaron pero no hay filas válidas.");
    return prep;
  } catch (e){
    console.warn(e);
    return null;
  }
}

async function loadDataFromFiles(){
  const f1 = els.fPol.files?.[0];
  const f2 = els.fMeta1.files?.[0];
  const f3 = els.fMeta2.files?.[0];
  if (!f1 || !f2 || !f3) throw new Error("Sube los 3 ficheros CSV.");
  const [t1,t2,t3] = await Promise.all([readFileAsText(f1), readFileAsText(f2), readFileAsText(f3)]);
  const dfPol = parseCSV(t1);
  const dfM1 = parseCSV(t2);
  const dfM2 = parseCSV(t3);
  const prep = prepararSeriesPct(dfPol, dfM1, dfM2);
  if (!prep) throw new Error("No hay filas válidas tras parsear los CSV.");
  return prep;
}

/* ===========================
   Eventos UI
   =========================== */
els.togX999.addEventListener("change", ()=>{ if(app.prepared) applyVisibilityToggles(); });
els.togOtros.addEventListener("change", ()=>{ if(app.prepared) applyVisibilityToggles(); });
els.btnReset.addEventListener("click", ()=> resetFocus());
els.btnDownload.addEventListener("click", ()=>{ if(app.prepared) downloadJSON(); });

els.search.addEventListener("input", ()=> applySearch());

els.btnFocusSS.addEventListener("click", ()=>{
  if(!app.prepared) return;
  const allLabels = Array.from(app.prepared.series.keys());
  const focus = findFocusLabel(allLabels);
  if (focus) setFocus(new Set([focus]));
});
els.btnFocusSE.addEventListener("click", ()=>{
  if(!app.prepared) return;
  const allLabels = Array.from(app.prepared.series.keys());
  const san = findLabelByKeywords(allLabels, ["sanidad","salud"]);
  const edu = findLabelByKeywords(allLabels, ["educacion","enseñanza","ensenanza"]);
  const set = new Set([san, edu].filter(Boolean));
  if (set.size) setFocus(set);
});
els.btnStory.addEventListener("click", ()=> storyMode());

els.btnUseFiles.addEventListener("click", async ()=>{
  try{
    setStatus("Procesando ficheros subidos…", true);
    const prep = await loadDataFromFiles();
    els.dropZone.style.display = "none";
    buildPlot(prep);
  } catch(e){
    setStatus("Error: " + e.message, false);
  }
});

/* ===========================
   Inicio
   =========================== */
(async function init(){
  setStatus("Buscando CSV locales…", true);
  const prep = await loadDataDefault();
  if (!prep){
    setStatus("No encuentro los CSV (sube ficheros)", false);
    els.dropZone.style.display = "";
    // pinta un plot vacío “bonito”
    Plotly.newPlot("plot", [], {
      margin:{ l:60, r:20, t:20, b:55 },
      paper_bgcolor:"rgba(0,0,0,0)",
      plot_bgcolor:"rgba(0,0,0,0)",
      font:{ color: PALETTE.text, family:"Arial, system-ui, sans-serif" },
      xaxis:{ title:{text:"Año"}, gridcolor:"rgba(74,74,74,.45)", zeroline:false, showline:true, linecolor:"rgba(176,176,176,.7)" },
      yaxis:{ title:{text:"Porcentaje del total (%)"}, gridcolor:"rgba(74,74,74,.45)", zeroline:false, showline:true, linecolor:"rgba(176,176,176,.7)" },
      annotations: [{
        text: "Sube los CSV para generar el gráfico",
        xref:"paper", yref:"paper", x:0.5, y:0.5, showarrow:false,
        font:{ size: 16, color: PALETTE.text }
      }]
    }, { displayModeBar:false, responsive:true });
    return;
  }
  buildPlot(prep);
})();
</script>
</body>
</html>
